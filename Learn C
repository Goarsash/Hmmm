
#include<stdio.h>

//////////////////////game.h (searching mine)
#pragma once
#include<stdio.h>
#include<time.h>
#include<stdlib.h>
#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define Mines 80

void InitBoard(char board[ROWS][COLS],int rows,int cols,char set);

void DisplayBoard(char board[ROWS][COLS], int row, int col);

void SetMine(char board[ROWS][COLS], int row, int col);

void DetectMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);


///////////////////game.c
#include"game.h"


void InitBoard(char board[ROWS][COLS], int rows, int cols,char set)
{
	int i = 0;
	int j = 0;
	
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i <= col; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ",i);
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}

void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = Mines;
	while (count)
	{
		int x = rand() % row+1;
		int y = rand() % col+1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}
//a ,b is the char number
//'a'+'b'=a+b(number)
//'a'+'0'=a(number)

int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y] +
		mine[x - 1][y - 1] +
		mine[x][y - 1] +
		mine[x + 1][y - 1] +
		mine[x + 1][y] +
		mine[x + 1][y + 1] +
		mine[x][y + 1] +
		mine[x - 1][y + 1] - 8 * '0';


}

void DetectMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	
	while (win<row*col- Mines)
	{
		printf("Please enter the site you want(with a space in the middle) : ");
		scanf("%d%d", &x, &y);
		//whether this shit illigal?
		//1 dead
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (mine[x][y] == '1')
			{
				printf("saddly, you dead \n");
				DisplayBoard(mine, row, col);
				break;
			}
			else//continue or win
			{
				//conut the number of mines surrounding the site
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("Wrong answer,trt again later\n");

		}
	}
	if (win == row * col - Mines)
	{
		printf("you win!!!\n");
		DisplayBoard(mine, row, col);
	}
}
/////////////test.c

#include"game.h"
void menu()
{
	printf("*******************************\n");
	printf("****1   Play     0  Quit*******\n");
	printf("*******************************\n");
}

void game()
{
	//data storing
	//1 Settle mine  data
	char mine[ROWS][COLS] = { 0 };
	//2 Detect mine data
	char show[ROWS][COLS] = { 0 };
	//3 Renew the board
	InitBoard(mine, ROWS, COLS,'0');
	InitBoard(show, ROWS, COLS,'*');
	//the surface
	//DisplayBoard(mine,ROW,COL);
	DisplayBoard(show,ROW,COL);
	// set the mine
	SetMine(mine,ROW,COL);
	DisplayBoard(mine, ROW, COL);
	//detect the min
	DetectMine(mine,show,ROW,COL);
	
}
void test()
{
	int input = 0;	
	srand((unsigned int)time(NULL));
	do
	{
		menu();
		printf("Please enter your choice :  ");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("Quitting the game now \n");
			break;
		default:
			printf("Wrong answer,Check the number and enter again\n");
			break;
	    }
	} while (input);

}
int main(void)
{

	test();

	return 0;
}












/////////////////////////////////////////////////////////////

int main(void)
{
	int arr[] = { 1,2,3,4,57,889 };
	printf("%p \n", arr);//数组名及首元素地址
	printf("%p \n", &arr[0]);
	printf("%d \n", *arr);//就是首元素的地址
	return 0;
}
例外情况（数组名不代表首元素地址）
1 sizeof(数组名)，此时数组名标准整个数组，求得整个数组的大小
2 &arr 取地址数组名，取出的是整个数组的地址


///////////////////////////////////////////////////////////////
算术左移，相当x2 的效果
int main(void)
{
	int a = 9;
	int b = a << 1;
	printf("%d \n", b);
	//左边丢弃，右边补0 符号位不变

	return 0;
}


移位操作符 ——算术右移位，，右移移位相当于除2 的效果
int main(void)
{
	int a = -8;
	int b = a >> 2;
	printf("%d \n", b);
	printf("%p \n", &a);
	//10000000000000000000000000001000  -8
	//10000000000000000000000000000100  -4
	return 0;
}

/////////////////////////////////////////////////////////////

int main(void)
{
	int a = 3;//00000000000000000000000000000011
	int b = 5;//00000000000000000000000000000101
	int c = a & b;//按位与 有一个0 就为0 两个都为1  才为1  00000000000000000000000000000001  1
	int d = a | b;//按位或 有一个为1则为1 两个都为0 才为0  00000000000000000000000000000111 7
	int e = a ^ b;//按位异或  相同为0 相异为1 00000000000000000000000000000110 6

	printf("%d \n", c);//1
	printf("%d \n", d);//7
	printf("%d \n", e);//6
	return 0;

//////////////////////////////////////////////////////
int main()
{
	int a = 0;
	printf("%d\n", ~a);
	//~按（二进制）位取反
	//a
	//00000000000000000000000000000000 正数的原反补码相同
	//11111111111111111111111111111111-补码 storage
	//11111111111111111111111111111110-反码
	//10000000000000000000000000000001-原码 surface  -1
	return 0;
}


//////////////////////////////////////////////////


int main()
{
	int i = 0;
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	//i = a++ && ++b && d++;//逻辑与只要遇到一个0 直到遇到0 那么后面不管是什么，忽略 1，2，3，4
	//i = a++ || ++b || d++; //1，3，3，4 逻辑或，只要遇到一个真 那么后面不管是什么 直到遇到一个真，忽略
	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);

	return 0;
}

////////////////////////////////////////////////////
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int max = (a > b ? a : b);//三目操作符
	printf("max = %d \n", max);


	return 0;
}


////////////////////////////////////////////
野指针
//临时变量出test函数后就销毁了 
int* test()
{
	int a = 10;
	return &a;
}

//*p 由于原来的地址已经销毁，故为野指针
int main()
{
	int* p =test();

	printf("%d\n", *p);
	return 0;
}
///////////////////////////////////////////
int main()
{
	//指针-指针，两个指针必须指向同一个空间
	char ch[5] = { 0 };
	int a[10] = {99,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", &a[9] - &a[0]);//指针-指针得到的是中间的元素个数；
	printf("%d\n", &a[0] - &a[9]);
	printf("%d\n", &a[9] - &ch[4]);//Wrong

	return 0;
}
/////////////////////////////
[Using point to explain strlen]
int My_strlen(char* str)
{
	char* start = str;
	char* end = str;
	while (*end != '\0')
	{
		end++;
	}
	return end - start;

}

int main(void)
{
	char arr[] = "Fuck you up";
	int len = My_strlen(arr);
	printf("%d\n", len);

	return 0;
}

///////////////////////////////////////////
struct Stu
{
	char name[20];
	short age;
	char sex[5];
}Stu; // 此处的Stu是全局变量

typedef struct Stu  //typedef 重新取个名字
{
	char name[20];
	short age;
	char sex[5];
}Stu;//重新取得名字  此处的stu是类型 而不是全局变量 =（int folat char...)


int main(void)
{
	struct Stu s = { "Frank",20,"male" };
	Stu s1;
	printf("%s\n", s);

	return 0;
}

////////////////////////////////////////////
struct S
{
	int age;
	char arr[20];
	double c;

};

struct T
{
	char ch[20];
	struct S s;
	char* p;

};

int main(void)
{
	char arr[60] = "Never gonna give you up";
	struct T t = { "hehe",{20,"aosijd",2.7},arr};//嵌套结构体

	//打印结构体内部对象 结构体名.对象
	printf("%s\n", t.ch);
	printf("%d\n", t.s.age);
	printf("%s\n", t.s.arr);

	return 0;
}

////////////////////////////////////////////////////////////
typedef struct Stu
{
	char name[29];
	short age;
	char tele[20];
}Stu;
void print1(Stu tmp)
{
	printf("name = %s\n", tmp.name);
	printf("age = %d\n", tmp.age);
	printf("tele = %s\n", tmp.tele);
}
//结构体指针
void print2(Stu* ps)
{
	printf("name = %s\n", ps->name);  //结构体指针->结构体成员
	printf("age = %d\n", ps->age);
	printf("tele = %s\n", ps->tele);
}
int main()
{
	Stu s1 = { "Frank",20,"13355669977" };
	//传值 需要开辟空间来存零时拷贝
	print1(s1);
	//传址 打印的话更优 不用开辟空间来存临时拷贝
	print2(&s1);
	return 0;
}
