#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	printf("int    = %5d \n", sizeof(int));
//	printf("float  = %5d \n", sizeof(float));
//	printf("double = %5d \n", sizeof(double));
//	printf("char   = %5d \n", sizeof(char));
//
//	return 0;
//}
//int main(void)
//{
//	int p = 1;
//	int q = 2;
//	do
//	{
//		p = p + q;
//		q = q + 1;
//
//
//	} while (q <= 100);
//	printf("total sum = %d\n ", p);
//	return 0;
//}

//int main(void)
//{
//	int  stus;
//	double money, ave, total;
//	ave = 0;
//	stus = 0;
//	money = 0;
//	total = 0;
//	for (stus = 1; stus < 1000; stus++)
//	{
//		printf("how much money do you want to denote : ");
//		scanf("%lf", &money);
//		total = total + money;
//	
//		if (total >= 100000)break;
//	}
//	ave = total / stus;
//	printf("there are %d students paying their money, and each one denote about %lf \$ in average\n",stus,ave);
//
//	return 0;
//}
//
//int main(void)
//{
//	int arr[4][5] = { {1,2,3,4,5},{2,4,6,8,10},{3,6,9,12,15},{4,8,12,16,20} };
//	int i = 0;
//	int j = 0;
//	for (i = 0; i <= 3; i++)
//	{
//		for (j = 0; j <= 4; j++)
//		{
//			printf("%4d  ", arr[i][j]);
//
//		}
//		putchar('\n');
//	}
//
//	return 0;
//}
//
//int main(void)
//{
//	double m = 0.0;
//	int i = 1;
//	double sum = 0.0;
//	double pi = 0.0;
//
//	for (m = 1.0; m < 1e6; m = m + 2)
//	{
//		sum =  (i / m)+sum ;//注意除法必须有一个浮点数 结果才能是浮点数
//		i = -i;
//
//
//	}
//	pi = sum * 4;
//	printf("pi = %.5lf\n", pi);
//
//	return 0;
//}
//int main(void)
//{
//	int sign = 1;
//	double pi = 0.0, n = 1.0, trem = 1.0;
//	while (fabs(trem) >= 1e-5)
//	{
//		pi = pi + trem;
//		n = n + 2;
//		sign = -sign;
//		trem = sign / n;
//	}
//	pi = pi * 4;
//	printf("pi = %.20f", pi);
//
//
//
//	return 0;
//}

//pi/4=1-1/3+1/5-1/7+........   ==> pi=4(1-1/3+1/5-1/7+........)
//int main(void)
//{
//	int sign;
//	double pi = 0.0, term = 1.0,n=1.0;
//	sign = 1;
//	n = 1;
//	while(fabs(term)>=1e-6)
//	{
//		pi = pi + term;
//		sign = -sign;
//		n = n + 2;
//		term = sign / n;
//
//	}
//	pi = pi * 4;
//	printf("pi = %.5f\n", pi);
//
//	return 0;
//}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//指向函数指针数组的指针
//int main(void)
//{
//	int arr[10] = { 0 };
//	int(*p)[10] = &arr;
//
//	int (*pfarr[4])(int, int);//函数指针数组
//	int (*(*ppfarr)[4])(int, int);//指向函数指针数组的指针
//	//ppfarr是一个数组指针，指针指向的数组有4个元素
//	//指向的数组的每个元素的类型是一个函数指针 int(*)(int,int)
//	return 0;
//}

//回调函数

void print(char* str)
{
	printf("hh:%s", str);
}
void test(void(*p)(char*))
{
	printf("test\n");
	p("bit");

}

int main(void)
{
	test(print);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//一维  数组传参和指针数组传参

//数组
//void test1(int arr1[]);
//void test1(int* arr);
//void test1(int arr[10]);
////指针数组
//void test2(int* arr2[20]);
//void test2(int* arr2[]);
//void test2(int** arr2);
//
//
//
//int main(void)
//{
//	int arr1[10] = { 0 };
//	int* arr2[20] = { 0 };
//
//	test1(arr1);
//	test2(arr2);
//
//
//	return 0;
//}

//二维数组传参
//void test(int arr[3][5])//直接用数组来接收
//{} 
//void test(int arr[][5])//行可以省略，列不能省略
//{}
//void test(int (*p)[5])//用数组指针接收  （*p）表示是一个指针，指向的是第1行的地址 [5]表示每一行对应多少元素  int 表示对应的元素是int类型
//{}
//
//int main(void)
//{
//	int arr1[3][5] = { 0 };
//
//	test(arr1);//此处的arr1代表首元素地址，但arr1是一个二维数组 故此时的首元素的地址是第一行的地址
//
//	return 0;
//}

//void test(int* p);//一级指针传参 用指针接收
//void test2(int* p1);
//int main(void)
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	test(p);
//
//
//	test2();//此处可以放变量地址，一维数组名，指针
//	return 0;
//}

//void test(int** p)//传参二级指针 用二级指针来接收
//{}
//
//int main(void)
//{
//	int a = 10;
//	int* p = &a;
//	int** pp = &p;
//	int* arr[10];
//	test(pp);//二级指针本身
//	test(&p);//一级指针的地址
//	test(arr);//指针数组的数组名
//
//	return 0;
//}

//数组指针  指向数组的指针
//函数指针  指向函数的指针


//int ADD(int x, int y)
//{
//	return x + y;
//}
//int main(void)
//{
//	int a = 10;
//	int b = 20;
//	//printf("%d\n",ADD(a,b));
//
//	//在函数指针中 &ADD=ADD 都是函数的地址
//	printf("%p\n", &ADD);//函数地址
//	printf("%p\n", ADD);
//
//	int (*pa)(int,int) = ADD;//函数指针
//
//	printf("%d\n", (*pa)(2, 3));//（*pa）是找到ADD函数 （2，3）进行传参 相当于 ADD(2,3)
//	return 0;
//}
void Print(char* str)
{
	printf("%s", str);
}

int main(void)
{
	void(*p)(char*) = Print;//(*p)必须要加括号 否则p就会先与后面的括号结合 导致整体是一个函数声明
	(*p)("adasdasf");
	return 0;
}
//
//int main(void)
//{
//	(*(void (*)())0)();
//	(void (*)())  这是一个类型 
//   (void (*)()) 0 强制类型转换 将0转换为一个函数指针类型 此时0就是一个函数的地址
// (*(void (*)())0)   加上* 进行解引用操作，调用0地址处的该函数 
//  (*(void (*)())0)() 找到了这个函数 传了一个空的参数 并开始运行这个函数
	//void (*signal(int, void(*)(int)))(int);

// signal是一个函数声明 
// 
// signal函数有两个参数 一个为int类型，一个为函数指针，这个函数指针 该函数指针指向的函数的参数为int类型，返回类型为void
// 
// signal 函数的返回类型为 函数指针 这个函数指针类型指向的函数的参数为int类型，返回类型为void
// 
//void  (*signal(int, void(*)(int)))  (int)  相当于 void (*    )(int) 是个函数指针类型
// 
// 	   也就是 signal(int, void(*)(int)是函数名 返回类型是void(*)(int)
	//如果一个函数的返回类型是一个函数指针 那不能写成 void(*)(int) signal(int, int) 而要写成 void (*  signal(int, int)  ) (int)

	//简化
//	typedef unsigned int uint;             //typedef 的一般使用方法
//
//	typedef void(*pfun_t)(int);            //typedef在定义函数指针时与一般不同，定义的新名字要放在 *后面 此处见pfun_t
//
//	pfun_t signal(int, pfun_t);            // 这两句=void (*signal(int, void(*)(int)))(int)
//	return 0;
//}
//int ADD(int x, int y)
//{
//	return x + y;
//}
//int SUB(int x, int y)
//{
//	return x - y;
//}
//int MUL(int x, int y)
//{
//	return x * y;
//}
//int DIV(int x, int y)
//{
//	return x / y;
//}
//int main(void)
//{
//	int a = 10;
//	int b = 20;
//	/*int(*p)(int,int) = ADD;*/
//
//	int(*parr[4])(int, int)={ADD,SUB,MUL,DIV};//函数指针数组 用来存放相同类型的函数类型的指针
//
//	int i = 0;
//	for (i = 0; i < 4; i++)
//	{
//		printf("%d\n",parr[i](6, 2));//函数指针调用时可以不解引用
//
//	}
//
//	//printf("%d\n", p(3,4));//这个*实际上可加可不加
//	//printf("%d\n", ADD(3, 4));
//	//printf("%d\n" ,(*p)(3,4));
//
//	return 0;
//}

//char* my_strcpy(char* dest, const char* src);
//
//int main(void)
//{
//	char*(*pf)(char*, const char*) = my_strcpy;
//	char* (*pfArr[4])(char*, const char*);
//	return 0;
//}

//函数指针数组的应用  
//计算器程序
void menu()
{
	printf("***************************************\n");
	printf("***      1 ADD        2 SUB  **********\n");
	printf("****     3 MUL        4 DIV   *********\n");
	printf("******         0  EXIT      ***********\n");
	printf("***************************************\n");

}

int ADD(int x, int y)
{
	return x + y;
}
int SUB(int x, int y)
{
	return x - y;
}
int MUL(int x, int y)
{
	return x * y;
}
int DIV(int x, int y)
{
	return x / y;
}
int main(void)
{
	int input = 0;
	int num1 = 0;
	int num2 = 0;
	//函数指针数组  -- 转移表
	int(*pf[])(int, int) = {0,ADD,SUB,MUL,DIV};
	do
	{

		menu();
		printf("Please enter your choice:");
		scanf("%d", &input);
		if (input >= 1 && input <= 4)
		{
			printf("Please enter two number:");
			scanf("%d%d", &num1, &num2);
			printf("%d\n", pf[input](num1, num2));
		}
		else if (input == 0)
		{
			printf("EXIT\n");
		}
		else
			printf("Wrong answer,enter again later\n");

	}while(input);
	return 0;
}
//int main(void)
//{
//	int input = 0;
//	int num1 = 0;
//	int num2 = 0;
//	do
//	{
//		
//		menu();
//		printf("Please enter your choice:");
//		scanf("%d", &input);
//			
//		switch (input)
//		{
//		case 1:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("ADD=%d\n",ADD(num1, num2));
//			break;
//		case 2:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("SUB=%d\n", SUB(num1, num2));
//			break;
//		case 3:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("MUL=%d\n", MUL(num1, num2));
//			break;
//		case 4:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("DIV=%d\n", DIV(num1, num2));
//			break;
//		case 0:
//			printf("EXIT");
//			break;
//		default:
//			printf("wrong answer,enter again\n");
//			break;
//		}
//			
//	} while (input);
//
//	return 0;
//}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	char* p = "asdasdasd";//stable array (unchangeble data)
//	//actualy  the location of the first char(a) was saved by p(pinter)
//	printf("%c\n", *p);
//	printf("%s\n", p);
//
//	return 0;
//}

//int main(void)
//{
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	const char* p = "abcdef";
//	const char* p1 = "abcdef"; //constant 
//
//	if (p == p1)
//	{
//		printf("hehe\n");
//	}
//	else
//		printf("haha\n");
//



	/*printf("%p\n", arr1);
	printf("%p\n", arr2);*/
	//if (arr1 == arr2)  //this means the location of the first charaster
	//{
	//	printf("hehe\n");
	//}
	//else
	//	printf("haha\n"); //it is different between the location of the first charaster of arr1 and arr2

//	return 0;
//}

//指针数组  存放指针变量的数组
//int main(void)
//{
//	//int arr[10] = { 0 };//整型数组
//	//int* prr[4];//存放整型指针的数组
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	int d = 40;
//	int* prr[4] = { &a,&b,&c,&d };   //指针数组的使用
//	//printf("%d", *prr[0]);
//	int i = 0;
//	for (i = 0; i < 4; i++)
//	{
//		printf("%d ", *(prr[i]));
//
//	}
//	return 0;
//}
// 
// 
//指针数组主要用法
//int main(void)
//{
//	int arr1[] = { 1,2,9,4,5 };
//	int arr2[] = { 2,3,4,5,6 };
//	int arr3[] = { 3,4,5,6,7 };
//
//	int* parr[] = { arr1,arr2,arr3 };
//
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//	
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d  ", *(parr[i]+j));
//		}
//		
//		printf("\n");
//	}
//
//
//	return 0;
//}

//数组指针  指针
//int main(void)
//{
//	int* pd = 10; //整型指针————指向整型的指针————可以存放整型的地址
//	char* pc = 'w';//字符指针————指向字符的指针————可以存放字符的地址
//	              //数组指针————指向数组的指针——————可以存放数组的地址
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//     //arr 数组名 表示首元素的地址
//	//&arr 表示数组的地址
//	int(*parr)[10] = &arr;   //parr就是数组指针
//
//	//WRONG int* parr[10]=&arr 因为数组的优先级要比指针高，此处的parr表达的是一个指针数组
//
//	return 0;
//}
//int main(void)
//{
//	char* arr[5];
//	char*(*p)[5] = &arr;// 数组指针的格式：    数组类型 (*指针名) [元素个数] =&数组名
//
//	int arr1[10] = { 0 };
//	int (*pa)[10] = &arr1;
//	return 0;
//}

//int main(void)
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	/*int(*p)[10] = &arr;
//	int i = 0;*/
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d  ", *(p + i));
//	}
//	//数组指针这么用会很麻烦
//	//exp1
//	//for (i = 0; i < 10; i++)
//	//{
//	//	printf("%d ", (*p)[i]);//此处的*p其实为数组名
//	//}
//	//exp2
//	 //for (i = 0; i < 10; i++)
//	//{
//	//  printf("%d ", *(*p + i));//*p==arr
//	//}
//	return 0;
//}

void print1(int arr[3][5], int x, int y)//数组接收arr
{
	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 5; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}

void print2(int(*p)[5], int x, int y)  //此处要将arr想象为一维数组 
{
	int i = 0;
	for (i = 0; i < x; i++)
	{
		int j = 0;
		for (j = 0; j < y; j++)
		{
			printf("%d ", p[i][j]);
			//printf("%d  ", *(*(p + i) + j)); //p+i会直接跳过一行应为p存储的每一个元素为1行 加上j找到第p+i行的元素 再解引用得到这个元素
			//printf("%d  ", (*(p + i))[j]); //*(p)表示一整行的元素+i跳过这一行

		}
		printf("\n");

	}


}

int main(void)
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	//print1(arr,3,5);
	print2(arr,3,5);//arr为首元素地址 传参的时候 可以用数组接收 或指针接收
	//int arr[] = { 1,2,3,4,5 };
	//int* p = arr; //实际上p就是arr
	//int i = 0;
	//for (i = 0; i < 5; i++)
	//{
	//	//printf("%d ", *(p + i));
	//	//printf("%d ", *(arr + i));
	//	printf("%d ", p[i]);                                  arr[i]=*(arr+i)= *(p+i)= p[i]
	//	
	/*}*/


	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//void test(int arr[])//需要用指针变量或数组来接收实参
//{
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//64位的指针变量为 8个字节  32位为4个字节
//	//因为此处arr的元素为int类型 及占据4个字节 故此处为8/4=2
//	printf("size = %d\n",sz);
//}
//
//int main(void)
//{
//	int arr[10] = { 0 };
//
//	test(arr);//传过去的是首元素地址
//
//	return 0;
//}
//

//int main(void)
//{
//	char arr[] = "qweqwr";
//
//	char* pc=arr;
//	printf("%s\n", arr);
//	printf("%s\n",pc);
//	return 0;
//}

int main(void)
{
	const char* pc = "asdhaweqwdr";//"asdhaweqwdr"此处是在内存中创建了一个常量字符串
	//加const进一步保护代码
	*pc = 'w';//常量字符串是无法被改变的
	printf("%s\n", pc);

	//pc指针变量是指向常量字符串的首元素地址a
	//printf("%c\n",*pc);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i); 9 8 7 6 5 4 3 2 1 0 Unisgned_int_max ---  无限循环
//		Sleep(100);
//	}
//	return 0;
//}

//int main(void)
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d\n",strlen(a));
//	//-1 ------> -128 -->127 --------->3,2,1,0
//	//128+127 =  255  stelen() end by  '\0'=0
//	return 0;
//}

//int main(void)
//{
//	unsigned char i = 0;
//	int count = 0;
//	//unsigned char :[0,255]                   always true
//	for (i = 0; i <= 255; i++)//               loop 225+1=0
//	{
//		printf("duck duck\n");
//		count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}
int main()
{

（-1)^S*M*2^E 浮点形数据在内存中的存储规则
	//float type store
	//v=(-1)^S*M*2^E   
	//S--- V正数S=0；V负数S=1
	//M---有效数字，大于等于1，小于2 [1,2)
	//2^E 指数位 E(unsigned int) 存入内存时 E的真实值必须加上中间值  8位存储时+127  （double)11位存储时+1023

	//9.0
	//1001.0
	//(-1)^0*1.001*2^3  此处的1.001实际上只存储了 .001 等拿出来时会补上1

	//0.5
	//0.1  2^-1
	//(-1)^0 * 1.0 * 2^-1
	//S= 0
	//M= 1.0
	//E=-1  =(float)(32位浮点数8位存储E时）     E+127=126 实际-1存储的是126
	//      =(double)（64位的浮点数11位存储E时） E+1023=1022 实际的-1存储的是1022




	int n = 9;
	//00000000 00000000 00000000 00001001----- 9的二进制补码
	float*p=(float*)& n;
	printf("n= %d\n", n);//9
	printf("p=%f\n", *p);//0 00000000  00000000000000000001001  (-1)^0 * 0.00000000000000000001001 * 2^-126 ->0

	*p = 9.0;
	//1001.0     
	//(-1)^0 * 1.001 * 2^3    
	//0 10000100 00100000000000000000000
	printf("n = %d\n", n); //2^31+2^26+2^23
	printf("*p=%f\n", *p); //(-1)^0*1.001*2^3=9.0


	return 0;
}

//int main()
//{
//	float f = 5.5;//0X40b00000
//	//00 00 b0 40  小端存储  两个两个一拿
//
//
//	return 0;
//}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int check_sys()
//{
//	int a = 1;
//	//char* p = &a;
//	/*if (*p == 1)
//		return 1;
//	else
//		return 0;*/
//	//return 1 little
//	//return 0 big
//
//	//return *p;
//
//	return *(char*)&a;
//	
//	//指针类型的意义
//	//1 指针类型决定了解引用操作能访问的字节数 char* 1个字节  int* 4个字节
//	//2 指针类型决定了指针+1 -1  加的或减的是几个字节 char*p p+1跳过一个字节  int*p  p+1跳过4个字节
//
//}
//
//int main(void)
//{
//	//判断本机存储字序方式
//
//	/*int a = 999999999999999999;
//
//	char* p = (char*) & a;
//	if (*p != 0)
//	{
//		printf("small\n");
//	}
//	else
//		printf("big\n");*/
//	//return 1 little
//	//return 0  big
//	int ret = check_sys();
//	if (ret == 1)
//		printf("littel\n");
//	else if (ret == 0)
//		printf("big\n");
//	else
//		printf("wrong\n");
//
//
//
//	return 0;
//}

//int main(void)
//{
//	int a = 0x11223344;
//	/*int* pd = &a;
//	*pd = 0;*/
//	char* pc = &a;
//	*pc = 0;
//	printf("%d\n", a);
//	return 0;
//}





int main(void)
{
	char a = -128;
	signed char b = -1;
	unsigned char c = -128;
	//10000000000000000000000000000001
	//11111111111111111111111111111110
	//11111111111111111111111111111111
	//由于定义的是char类型 打印的是int类型 打印时需要对补码先进行整型提升
	// 
	// 发生截断时 最后截断的数据是根据本机储存形式来确定 是      大端存储（截断前面）         还是小端存储（截断后面）
	// 
	// 整型提升是更具当前数据储存变量来决定 有符号（扩充符号位） 无符号（扩充0）
	//a 11111111  -》》 11111111111111111111111111111111   -----》10000000000000000000000000000001   -----》-1
	//b 11111111  -》》 11111111111111111111111111111111   -----》10000000000000000000000000000001   -----》-1
	//c 11111111 ---->  00000000000000000000000011111111-------->00000000000000000000000011111111(z正数原反补相同 --------》255


	unsigned char d = 255;
	printf("%u %d %d ", a, b, c);

	return 0;
}


//-128  10000000000000000000000010000000----
//      11111111111111111111111101111111
//      11111111111111111111111110000000
//      11111111111111111111111110000000 整型提升 char a = -128(有符号）
//     011111111111111111111111110000000  %u unsigned int 因为要求无符号 所以第一个1不再是符号位  4,294,967,168
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main()
//{
//	int i = 0;
//	int count = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	printf("%p\n", arr);
//	printf("%p\n", &i);
//	printf("%p\n", &count);
//	
//	system("pause");
//	for (i = 0; i <= 12; i++)
//	{
//		printf("hhe\n");
//		arr[i] = 0;   //当i>=10 时 就会出现非法访问
//		count++;
//
//	}
//	//printf("count = %d \n", count);
//	
//	return 0;
//}
//栈区根据地址的大小 分为高地址和低地址 
//栈区的默认使用规则是 先使用高地址，在使用低地址
//数组在内存中是连续存放的 随着小标的增长 由低到高进行储存

//创建的局部变量是放在栈上的 栈区是由高到低进行储存 故i 的地址比arr数组要高且随着数组下表的变大 地址会由低到高变化 故当arr数组越界访问时 可能会和i的地址重复 此时就会引发死循环
//Release 有优化变量存储结构的功能


//void my_strcpy(char* dest, char* src)
//{
//	while (*src != '\0')
//	{
//		*dest = *src;
//		src++;
//		dest++;
//	}
//	*dest = *src;
//}

//void my_strcpy(char* dest, char* src)
//{
//	while (*src != '\0')
//	{
//		*dest++ = *src++;
//		
//	}
//	*dest = *src;
//}

//void my_strcpy(char* dest, char* src)
//{
//	while (*dest++ = *src++)
//	{
//		;
//
//	}
//	
//}
//void my_strcpy(char* dest, char* src)
//{
//	if (dest != NULL && src != NULL)
//	{
//		while (*dest++ = *src++)
//		{
//			;
//
//		}
//	}
//	
//
//}

//char* my_strcpy(char* dest, const char* src)  //此处加const可以确保拷贝对象的不被改变
//{
//	char* ret = dest; 
//	assert(dest != NULL);
//	assert(src  != NULL);//include<assert.h>
//	//将src指向的字符串拷贝到dest指向的空间 包含'\0'字符
//		while (*dest++ = *src++)
//		{
//			;
//		}
//		return ret; //此处如果return dest  (ERR) 此地址已经改变 故需要建立一个零时指针变量 用来存储最初的dest指针地址
//}
//
//int main()
//{
//	char arr[] = "################";
//	char arr2[] = "bit";
//	
//
//	printf("%s\n", my_strcpy(arr, arr2));//链式访问 返回值最为另一个函数的参数
//	return 0;
//}

//int main()
//{
//	const int num = 10;//此处若建立指针变量，仍然可以修改
//
//	const int* p =&num; //const放在指针类型的左边 修饰的是*p  此时不能通过p来修饰*p（num)的值
//	//int* const p =&num; const 放在指针类型的右边， 修饰的是p 等于给指针变量p赋予了常属性 此时不能在改变指针变量p所指向的地址
//	*p = 20;
//	
//
//	printf("%d\n", num);
//	return 0;
//}
//


//int my_strlen(const char* arr)
//{
//	assert(arr != NULL);
//	int count = 0;
//	while (*arr != '\0')
//	{
//		count++;
//		
//		arr++;
//	}
//	return count;
//}
//
//
//int main()
//{
//	char arr[] = "qwejqwe";
//
//	int len = my_strlen(arr);
//
//	printf("length = %d \n", len);
//	return 0;
//}


//int main()
//{
//	int a = 10;    //0a 00 00 00 d3 8e d6 6e f8
//	float b = 10.0;//00 00 20 41 00 00 00 00 00
//	//不同类型存储方式之间的不同
//	//1 开辟的空间大小不同
//	//2 存储方式不同
//	return 0;
//}

//void test(void)//没有定义形式参数来接收实参时 直接忽略实参
//{
//
//	printf("hehe\n");
//}
//int main()
//{
//	int a = -8;
//
//	return 0;
//}


//整型在内存中的存储方式 -----二进制补码
                            // 负数
// 显示的是原码             eg:-8      10000000000000000000000000001000
// 原码按位取反得到反码      eg:-8      11111111111111111111111111110111
// 反码+1得到补码           eg:-8      1111 1111 1111 1111 1111 1111 1111 1000    
                                   // F     F    F   F    F    F    F    8     0xFFFFFFFF8   f8 ff ff ff 00 00 00 00 00(小端存储模式）
//大端存储模式 ---低位放在高地址，高位放在低地址
//小端存储模式 ---低位放在低地址，高位放在高地址
// 从左到右 越来越大
// 低位---------------------------高位
// 0xFFFFFFFF8  F8为低位  
// 
// 
// 
            //正数 （原，反，补码相同）
//原码   eg:8    00000000000000000000000000001000
//反码           00000000000000000000000000001000
//补码           00000000000000000000000000001000


//CPU只有加法  补码进行运算
//EG： 1-1  =》1+（-1）
//00000000000000000000000000000001   1
//11111111111111111111111111111111  -1
//00000000000000000000000000000000   0







///////////////////////////////////////////////////////////////////
//int main()
//{
//	int i = 0;
//	for (i = 0; i < 20; i++)
//	{
//		printf("%d  ", i);
//	}
//	system("pause");
//	return 0;
//}
//
//
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int i = 0;
//	for (i = 0; i <= 12; i++)
//	{
//		printf("hehe\n");
//		arr[i] = 0;
//	}
//	system("pause");
//
//	return 0;
//}


//设置断点  F9 配和 F5一起使用
//int main()
//{
//	int i = 0;
//	for (i = 0; i < 100; i++)
//	{
//		printf("%d ", i);
//	}
//
//	for (i = 0; i < 100; i++)
//	{
//		printf("%d ", 10-i);
//	}
//
//	
//	return 0;
//}

//int ADD(int x, int y)
//{
//	return x + y;
//}
//
//int main()
//{
//	printf("hehe\n");
//	int i = 0;
//	int b = 10;
//	int c = ADD(i, b);
//	printf("%d \n", c);
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i;
//		printf("%d \n", arr[i]);
//	}
//
//	return 0;
//}
//void test2()
//{
//	printf("fuck you \n");
//}
//
//void test1()
//{
//	test2();
//}
//void test()
//{
//	test1();
//}
//int main()
//{
//
//	test();
//	return 0;
//}


//typedef struct ASS
//{
//	char name[20];
//	int age;
//	char sex[10];
//}ASS;
//
//
//
//void print1(ASS* p)
//{
//	printf("name :  %s\n", p->name);
//	printf("age  :  %d\n", p->age);
//	printf("sex  :  %s\n", p->sex);
//
//}
//
//void print2(ASS p)
//{
//	printf("name :  %s\n", p.name);
//	printf("age  :  %d\n", p.age);
//    printf("sex  :  %s\n", p.sex);
//
//}
//int main()
//{
//	ASS s = { "frank",20,"male" };
//	print1(&s);
//	print2(s);
//	return 0;
//}
//	

//1!+2!+3!+...+n!

int main()
{
	int n = 0;//enter the final number!
	int sum = 0;//the final answer
	int i = 0;//the number of 1 to n
	int x = 0;//the n!
	int y = 1;
	printf("Please enter the number you want :  ");
	scanf("%d", &n);
	for (i = 1; i <= n; i++)
	{
		y = 1;
		for (x = 1; x <= i; x++)
		{
			y = x * y;
		}
		sum = sum + y;

	}
	printf("%d \n", sum);

}


int main()
{
	int i = 0;
	int sum = 0;
	int n = 0;
	int ret = 1;
	scanf("%d", &n);
	for (i = 1; i <= n; i++)
	{
		int j = 0;
		ret = 1;//ret 需要初始化
		for (j = 1; j <= i; j++)
		{
			ret *= j;
		}
		sum += ret;
	}
	printf("%d\n", sum);

	return 0;
}


////////////////////////////////////////////////////////////////////////////////////
// .c文件通过编译变为可执行文件  .exe
//debug 文件 即调试文件 的调试可执行文件 包含了调试信息
//release 发行文件不会包含可调试文件，因此会比debug文件要小




int main()
{
	int i = 10;
	for (i = 10; i < 20; i++)
	{
		printf("%d  ", i);
	}
	system("pause"); //使得直接使用debug文件时，cmd可以停留在桌面#inuclude<stdlib.h>
	return 0;
}







//typedef struct Stu
//{
//	char name[20];
//	char tele[12];
//	short age;
//	char sex[8];
//}Stu;
// 
//void print2(Stu tmp) 传值  会导致压栈 在时间和空间上都逊色与传址
//{
//	printf("name : %s\n", tmp.name);
//	printf("tele : %s\n", tmp.tele);
//	printf("age  : %d\n", tmp.age);
//	printf("sex  : %s\n", tmp.sex);
//	
//}
//void print1(Stu* tmp)   传址  不会压栈 节省计算机资源 
//{
//	printf("name : %s\n", tmp->name);
//	printf("tele : %s\n", tmp->tele);
//	printf("age  : %d\n", tmp->age);
//	printf("sex  : %s\n", tmp->sex);
//	printf("\n");
//}
//
//int main()
//{
//	Stu s1 = {"Frank","13552868009",20,"male"};
//
//	print1(&s1);//传址最佳
//	print2(s1); //传值次之
//
//	return 0;
//}




//struct S
//{
//	int a;
//	char arr[20];
//	double f;
//};
//
//struct T
//{
//	char ch[10];
//	struct S s;
//	char* p;
//};
//
//int main()
//{
//	char arr[20] = "fuck you up";
//	struct T t = { "frank",{66,"hello",3.14},arr };
//
//	printf("%s\n", t.ch);
//	printf("%lf\n", t.s.f);
//	printf("%s\n", t.p);
//
//	return 0;
//}
//








/////////////////////////
#pragma once

#define ROW 3
#define COL 3

#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//function naming
void InitBoard(char board[ROW][COL], int row, int col);

//surface
void DisplayBoard(char board[ROW][COL], int row, int col);

//playing
void Playermove(char board[ROW][COL], int row, int col);

void Computermove(char board[ROW][COL], int row, int col);

//judging have four situations
//player win   ---'*'
// computer win ---'#'
// no winner   ----'Q'
//continue ----'C'

char judge(char board[ROW][COL], int row, int col);

///////////////////////////////game.c
#include"game.h"


//function creating
void InitBoard(char board[ROW][COL], int row, int col)
{
	int i =0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			board[i][j] = ' ';

		}
	}

}

void DisplayBoard(char board[ROW][COL], int row, int col)
{
	int i = 0;
	 
	for (i = 0; i < row; i++)
	{
		/*printf(" %c | %c | %c\n",board[i][0],board[i][1],board[i][2]);*/
		int j = 0;
		for (j = 0; j < col; j++)
		{
			printf(" %c ", board[i][j]);
			if(j<col-1)
			printf("|");

		}
		printf("\n");

		if (i < row - 1)
		{
			for (j = 0; j < col; j++)
			{
				printf("---");
				if(j<col-1)
				printf("|");
			}
			printf("\n");
		}		
	}
}


void Playermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("It is your time \n");
	
	while (1)
	{
		printf("Enter the location you want : ");
		scanf("%d%d", &x, &y);
		//Are this two number possible?
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (board[x - 1][y - 1] ==' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
			{
				printf("this position has been occupied\n");
			}

		}
		else
		{
			printf("It is not excited,Enter again! \n");

		}


	}
}


void Computermove(char board[ROW][COL], int row, int col)
{
	printf("NPC moving : \n");
	int x = 0;
	int y = 0;
	while (1)
	{
		x = rand() % row;
		y = rand() % col;
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}	
}


// 1 full
// 0 Not full

int isfull(char board[ROW][COL], int row, int col)
{
	int i = 0;

	for (i = 0; i < row; i++)
	{
		int j = 0;
		for (j = 0; j < col; j++)
		{
			if (board[i][j] == ' ')
				return 0;
		}

	}
	return 1;
}


char judge(char board[ROW][COL], int row, int col)
{
	int i = 0;
	for (i = 0; i < row; i++)
	{
		if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][1] != ' ')
			return board[i][1];
	}
	for (i = 0; i < col; i++)
	{
		if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[1][i] != ' ')
			return board[0][i];
	}
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[1][1] != ' ')
		return board[0][0];
	if (board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[1][1] != ' ')
		return board[1][1];

	// no winner
	if (1 == isfull(board,ROW,COL))
	{
		return 'Q';
	}
	else
	 return 'C';
}


//////////////////////////////              test.c
#include<stdio.h>
#include"game.h"


void menu()
{
	printf("***********************\n");
	printf("****1 play  0 quit*****\n");
	printf("***********************\n");
}
//the creating of this game
void game()
{
	char ret = 0;
	printf("\nThree Word Chess \n");
	//creating a arrat to store the input data
	char board[ROW][COL]= {0};//we need a empty array
	// Renew the chess board
	InitBoard(board,ROW,COL);
	//print the surface
	DisplayBoard(board, ROW, COL);
	//playing the game
	while (1)
	{
		//player
		Playermove(board,ROW,COL);
		DisplayBoard(board, ROW, COL);
		//  who win?
		ret = judge(board, ROW, COL);
		if (ret != 'C')
		{
			break;
		}
		//computer
		Computermove(board, ROW, COL);
		DisplayBoard(board, ROW, COL);
		// who win?
		ret = judge(board, ROW, COL);
		if (ret != 'C')
		{
			break;
		}
		
	}
	if (ret == '*')
	{
		printf("you win \n");
	}
	else if (ret == '#')
	{
		printf("you lose the game\n");
	}
	else
	{
		printf("there is no winner \n");
	}
}

void text()
{
	int input = 0;
	srand((unsigned int)time(NULL));//only use one time 
	do
	{
		menu();
		printf("Please enter your choice :  ");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();

			break;
		case 0:

			printf("Quitting the game now \n");
			break;
		default:
			printf("\nWrong answer, please enter again\n");
			break;

		}

	} while (input);


}



int main(void)
{
	text();

	return 0;
}











//////////////////////game.h (searching mine)
#pragma once
#include<stdio.h>
#include<time.h>
#include<stdlib.h>
#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define Mines 80

void InitBoard(char board[ROWS][COLS],int rows,int cols,char set);

void DisplayBoard(char board[ROWS][COLS], int row, int col);

void SetMine(char board[ROWS][COLS], int row, int col);

void DetectMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);


///////////////////game.c
#include"game.h"


void InitBoard(char board[ROWS][COLS], int rows, int cols,char set)
{
	int i = 0;
	int j = 0;
	
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i <= col; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ",i);
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}

void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = Mines;
	while (count)
	{
		int x = rand() % row+1;
		int y = rand() % col+1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}
//a ,b is the char number
//'a'+'b'=a+b(number)
//'a'+'0'=a(number)

int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y] +
		mine[x - 1][y - 1] +
		mine[x][y - 1] +
		mine[x + 1][y - 1] +
		mine[x + 1][y] +
		mine[x + 1][y + 1] +
		mine[x][y + 1] +
		mine[x - 1][y + 1] - 8 * '0';


}

void DetectMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	
	while (win<row*col- Mines)
	{
		printf("Please enter the site you want(with a space in the middle) : ");
		scanf("%d%d", &x, &y);
		//whether this shit illigal?
		//1 dead
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (mine[x][y] == '1')
			{
				printf("saddly, you dead \n");
				DisplayBoard(mine, row, col);
				break;
			}
			else//continue or win
			{
				//conut the number of mines surrounding the site
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("Wrong answer,trt again later\n");

		}
	}
	if (win == row * col - Mines)
	{
		printf("you win!!!\n");
		DisplayBoard(mine, row, col);
	}
}
/////////////test.c

#include"game.h"
void menu()
{
	printf("*******************************\n");
	printf("****1   Play     0  Quit*******\n");
	printf("*******************************\n");
}

void game()
{
	//data storing
	//1 Settle mine  data
	char mine[ROWS][COLS] = { 0 };
	//2 Detect mine data
	char show[ROWS][COLS] = { 0 };
	//3 Renew the board
	InitBoard(mine, ROWS, COLS,'0');
	InitBoard(show, ROWS, COLS,'*');
	//the surface
	//DisplayBoard(mine,ROW,COL);
	DisplayBoard(show,ROW,COL);
	// set the mine
	SetMine(mine,ROW,COL);
	DisplayBoard(mine, ROW, COL);
	//detect the min
	DetectMine(mine,show,ROW,COL);
	
}
void test()
{
	int input = 0;	
	srand((unsigned int)time(NULL));
	do
	{
		menu();
		printf("Please enter your choice :  ");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("Quitting the game now \n");
			break;
		default:
			printf("Wrong answer,Check the number and enter again\n");
			break;
	    }
	} while (input);

}
int main(void)
{

	test();

	return 0;
}












/////////////////////////////////////////////////////////////

int main(void)
{
	int arr[] = { 1,2,3,4,57,889 };
	printf("%p \n", arr);//数组名及首元素地址
	printf("%p \n", &arr[0]);
	printf("%d \n", *arr);//就是首元素的地址
	return 0;
}
例外情况（数组名不代表首元素地址）
1 sizeof(数组名)，此时数组名标准整个数组，求得整个数组的大小
2 &arr 取地址数组名，取出的是整个数组的地址


///////////////////////////////////////////////////////////////
算术左移，相当x2 的效果
int main(void)
{
	int a = 9;
	int b = a << 1;
	printf("%d \n", b);
	//左边丢弃，右边补0 符号位不变

	return 0;
}


移位操作符 ——算术右移位，，右移移位相当于除2 的效果
int main(void)
{
	int a = -8;
	int b = a >> 2;
	printf("%d \n", b);
	printf("%p \n", &a);
	//10000000000000000000000000001000  -8
	//10000000000000000000000000000100  -4
	return 0;
}

/////////////////////////////////////////////////////////////

int main(void)
{
	int a = 3;//00000000000000000000000000000011
	int b = 5;//00000000000000000000000000000101
	int c = a & b;//按位与 有一个0 就为0 两个都为1  才为1  00000000000000000000000000000001  1
	int d = a | b;//按位或 有一个为1则为1 两个都为0 才为0  00000000000000000000000000000111 7
	int e = a ^ b;//按位异或  相同为0 相异为1 00000000000000000000000000000110 6

	printf("%d \n", c);//1
	printf("%d \n", d);//7
	printf("%d \n", e);//6
	return 0;

//////////////////////////////////////////////////////
int main()
{
	int a = 0;
	printf("%d\n", ~a);
	//~按（二进制）位取反
	//a
	//00000000000000000000000000000000 正数的原反补码相同
	//11111111111111111111111111111111-补码 storage
	//11111111111111111111111111111110-反码
	//10000000000000000000000000000001-原码 surface  -1
	return 0;
}


//////////////////////////////////////////////////


int main()
{
	int i = 0;
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	//i = a++ && ++b && d++;//逻辑与  只要遇到一个0 直到遇到0 那么后面不管是什么，忽略 1，2，3，4
	//i = a++ || ++b || d++; //1，3，3，4 逻辑或，只要遇到一个真 那么后面不管是什么 直到遇到一个真，忽略
	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);

	return 0;
}

////////////////////////////////////////////////////
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int max = (a > b ? a : b);//三目操作符
	printf("max = %d \n", max);


	return 0;
}


////////////////////////////////////////////
野指针
//临时变量出test函数后就销毁了 
int* test()
{
	int a = 10;
	return &a;
}

//*p 由于原来的地址已经销毁，故为野指针
int main()
{
	int* p =test();

	printf("%d\n", *p);
	return 0;
}
///////////////////////////////////////////
int main()
{
	//指针-指针，两个指针必须指向同一个空间
	char ch[5] = { 0 };
	int a[10] = {99,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", &a[9] - &a[0]);//指针-指针得到的是中间的元素个数；
	printf("%d\n", &a[0] - &a[9]);
	printf("%d\n", &a[9] - &ch[4]);//Wrong

	return 0;
}
/////////////////////////////
[Using point to explain strlen]
int My_strlen(char* str)
{
	char* start = str;
	char* end = str;
	while (*end != '\0')
	{
		end++;
	}
	return end - start;

}

int main(void)
{
	char arr[] = "Fuck you up";
	int len = My_strlen(arr);
	printf("%d\n", len);

	return 0;
}

///////////////////////////////////////////
struct Stu
{
	char name[20];
	short age;
	char sex[5];
}Stu; // 此处的Stu是全局变量

typedef struct Stu  //typedef 重新取个名字
{
	char name[20];
	short age;
	char sex[5];
}Stu;//重新取得名字  此处的stu是类型 而不是全局变量 =（int folat char...)


int main(void)
{
	struct Stu s = { "Frank",20,"male" };
	Stu s1;
	printf("%s\n", s);

	return 0;
}

////////////////////////////////////////////
struct S
{
	int age;
	char arr[20];
	double c;

};

struct T
{
	char ch[20];
	struct S s;
	char* p;

};

int main(void)
{
	char arr[60] = "Never gonna give you up";
	struct T t = { "hehe",{20,"aosijd",2.7},arr};//嵌套结构体

	//打印结构体内部对象 结构体名.对象
	printf("%s\n", t.ch);
	printf("%d\n", t.s.age);
	printf("%s\n", t.s.arr);

	return 0;
}

////////////////////////////////////////////////////////////
typedef struct Stu
{
	char name[29];
	short age;
	char tele[20];
}Stu;
void print1(Stu tmp)
{
	printf("name = %s\n", tmp.name);
	printf("age = %d\n", tmp.age);
	printf("tele = %s\n", tmp.tele);
}
//结构体指针
void print2(Stu* ps)
{
	printf("name = %s\n", ps->name);  //结构体指针->结构体成员
	printf("age = %d\n", ps->age);
	printf("tele = %s\n", ps->tele);
}
int main()
{
	Stu s1 = { "Frank",20,"13355669977" };
	//传值 需要开辟空间来存零时拷贝
	print1(s1);
	//传址 打印的话更优 不用开辟空间来存临时拷贝
	print2(&s1);
	return 0;
}
