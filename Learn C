#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(void)
{
	int a = 10;
	int b = 20;
	int* p = &a;
	int* p1 = &b;
	printf("%d\n", *p+(*p1));


	/*printf("%p\n", &a);
	printf("%p\n", p);
	printf("%p\n", &p);
	printf("%d\n", *p);*/
	return 0;
 }




//float AVERAGE(float arr[])
//{
//	float sum = 0;
//	int i = 0;
//	int sz;
//	float a;
//	for (i = 0; i < 4; i++)
//	{
//		sum = sum + arr[i];
//	}
//	sz = sizeof(arr)/sizeof(arr[0]);
//	a = sum / 4;
//	return a;
//}
//
//int main(void)
//{
//	float score[4], aver;
//	int i = 0;
//	printf("input four number >:\n");
//	for (i = 0; i < 4; i++)
//	{
//		printf("  NO.%d: ", i + 1);
//		scanf("%f", &score[i]);
//	}
//	aver = AVERAGE(score);
//	printf("the average score of these students is %5.2f\n", aver);
//	return 0;
//}
//



//int main(void)
//{
//	int n, m = 0;
//	int arr[10] = { 4,5,3,6,1,7,8,9,10,57 };
//	for (n = 1; n < 10; n++)
//	{
//		if (arr[m] < arr[n])
//		{
//			m = n;
//		}
//	}
//	printf("the biggest number in this array is %d  and its subscript is [%d]", arr[m], m);
//
//	return 0;
//}

//
//void move(char x, char y)
//{
//	printf("%c--->%c\n", x, y);
//
//}
//
//
//void hanoi(int n, char one, char two, char three)
//{
//	if(n == 1)
//		move(one, three);
//	else
//	{
//		hanoi(n - 1, one, three, two);
//		move(one, three);
//		hanoi(n - 1, two, one, three);
//	}
//}
//int main(void)
//{
//	int m;
//	printf("input the number of the diskes:");
//	scanf("%d", &m);
//	printf("the step to move %d diskes:\n", m);
//	hanoi(m, 'A', 'B', 'C');
//	return 0;
//}
//
//int main(void)
//{
//
//	printf("%lld\n", pow(2, 10));
//}




//int factorical(int x)
//{
//	int total = 0;
//	if (x < 0)
//	{
//		printf("n<0 wrong data\n");
//	}
//	else if (x == 0 || x == 1)
//	{
//		total = 1;
//	}
//	else total = factorical(x - 1) * x;
//
//	return total;
//}
//
//
//int main(void)
//{
//	int num = 0;
//	scanf("%d", &num);
//	printf("%d ! = %lld", num, factorical(num));
//	return 0;
//}







//int AGE(int x)
//{
//	int c;
//	if (x == 1)
//	{
//		c = 10;
//	}
//	else
//	{
//		c = AGE(x - 1) + 2;
//	}
//	return c;
//}
//
//int main(void)
//{
//	printf("NO.5 age = %d\n", AGE(5));
//
//	return 0;
//}






//int ADD(int x, int y)
//{
//	return x + y;
//}
//int MAX(int x, int y)
//{
//	int z = x > y ? x : y;
//	return z;
//
//}
//int SHIT(int x, int y)
//{
//	return x + ADD(x, y);
//
//}
//int BIGGEST(int a, int b, int c, int d)
//{
//	int z = MAX(a, b);
//	int f = MAX(c, d);
//	return (z > f ? z : f);
//
//
//}
//int main(void)
//{
//	
//	int a = 10;
//	int b = 20;
//	int d = 40;
//	int f = 50;
//
//	int c = SHIT(a, b);
//	printf("%d\n",ADD(a, b));
//	printf("%d\n", MAX(a, b));
//	printf("%d\n", c);
//	printf("%d\n", BIGGEST(a, b, f, d));
//	return 0;
//}





//void stars(void)
//{
//
//	printf("*************\n");
//
//}
//
//int main(void)
//{
//
//	stars();
//	printf("hello world\n");
//	stars();
//
//
//	return 0;
//}





//int main(void)
//{
//	char arr[30] = { 0 };
//	gets(arr);
//	puts(arr);
//
//	return 0;
//}



//int main(void)
//{
//
//	int i, j, t;
//	int arr[10] = { 0 };k,
//
//	for (i = 0; i < 10; i++)
//	{
//		scanf("%d", &arr[i]);
//	}
//
//	for(j=0;j<9;j++)
//		for (i = 0; i < 9-j; i++)
//		{
//			if (arr[i] < arr[i + 1])
//			{
//				t = arr[i];
//				arr[i] = arr[i + 1];
//				arr[i + 1] = t;
//			}
//		}
//	printf("the sorted number is :\n");
//	for (i = 0; i < 10; i++)
//	{
//
//		printf("%d  ", arr[i]);
//
//	}
//
//
//	return 0;
//}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FIBONACCI

//int main(void)
//{
//	int F1, F2, sum = 1, flag = 0, back = 0;
//	F1 = 1;
//	F2 = 1;
//	for (flag = 0; flag <= 40; flag++)
//	{
//		sum = F1 + F2;
//		F1 = F2;
//		F2 = sum;
//		printf("%10d  ", sum);
//		back++;
//		if (back == 5)
//		{
//			putchar('\n');
//			back=0;
//			
//		}
//	}
//
//	return 0;
//}

//int main(void)
//{
//	int F[20] = { 1,1 };
//	int i = 0;
//	for (i = 2; i < 20; i++)
//	{
//		F[i] = F[i - 2] + F[i - 1];
//	}
//	for (i = 0; i < 20; i++)
//	{
//		if (i % 5 == 0)putchar('\n');
//		printf("%12d", F[i]);
//		
//	}
//	putchar('\n');
//	return 0;
//}

//int main(void)
//{
//	int arr[9] = { 0 };
//	int i, j, t;
//	for (i = 0; i < 10; i++)
//	{
//		scanf("%d", &arr[i]);
//	}
//	for (j = 0; j < 9; j++)
//		for (i = 0; i < 9 - j; i++)
//		{
//			if (arr[i] > arr[i + 1])
//			{
//				t = arr[i];
//				arr[i] = arr[i + 1];
//				arr[i + 1] = t;
//			}
//
//	    }
//
//	printf("the sorted number is :\n");
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d  ", arr[i]);
//	}
//	return 0;
//}

//int main(void)
//{
//	int A[2][3] = { {1,2,3},{4,5,6} };
//	int B[3][2];
//	int i, j;
//	for(i=0;i<2;i++)
//		for (j = 0; j < 3; j++)
//		{
//			B[j][i] = A[i][j];
//		}
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 2; j++)
//		{
//			printf("%d  ", B[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}
//int main(void)
//{
//	int a[3][4] = { {1,5,7,9},{4,6,9,0},{33,44,55,-88} };
//	int i, j, max = a[0][0];
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 4; j++)
//		{
//			if (max < a[i][j])
//				max = a[i][j];
//			printf("%5d  ", a[i][j]);
//		}
//
//		putchar('\n');
//	}
//
//	printf("the biggest number is %d \n", max);
//	return 0;
////}
//int main(void)
//{
//
//	printf("fuck yo\0u\n");//遇到\0结束
//	return 0;
//}
int main(void)
{
	/*char arr[] = "fuck you up";
	int sz = sizeof(arr) / sizeof(arr[0]);
	printf("%d\n", sz);
	int str=str*/
	char s1[5], s2[5], s3[5];
	scanf("%s%s%s", s1, s2, s3);
	printf("%s  %s   %s", s1, s2, s3);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	double k, sum = 0, p = 0, div = 0, total = 0;
//	for (k = 1; k <= 100; k++)
//	{
//		sum = sum + k;
//	}
//	for (k = 1; k <= 50; k++)
//	{
//		p = p + pow(k, 2);
//	}
//	for (k = 1; k <= 10; k++)
//	{
//		div = div + 1 / k;
//	}
//	total = sum + p + div;
//	printf("total = %f\n", total);
//
//	return 0;
//}
// 
// 

//DAFFODILS
//int main(void)
//{
//	int daf, hundred, ten, div, total;
//	for (daf = 100; daf <= 99999; daf++)
//	{
//		hundred = daf / 100;                                     //取模取得是余数
//		ten = (daf - hundred * 100) / 10;
//		div = (daf - hundred * 100 - ten * 10)/1;
//		total = pow(hundred, 3) + pow(ten, 3) + pow(div, 3);
//		if (total == daf)
//		{
//			printf("\n%d is a daffodils number,and its number is %d  %d  %d\n", daf, hundred, ten, div);
//		}
//	}
//
//	return 0;
//}


//int main(void)
//{
//	int a = 0;
//	a=2 % 3;
//	printf("%d\n", a);
//	return 0;
//}

//int main(void)
//{
//	int num, a, b, c, total=0;
//	for (a = 1; a < 1000; total = 0, a++)
//	{
//		for (b = 1; b < 1000; total = 0, b++)
//		{
//			for (c = 1; c < 1000; c++)
//			{
//				total = a * b * c;
//				if (total >= 1000)continue;
//				if (total == a + b + c)
//					printf("%d its factors are %d,%d,%d\n", total, a, b, c);
//				
//			
//			}
//
//		}

//
//	}
//
//
//	return 0;
//}
求完数
int main(void)
{
	int m, s, i;
	for (m = 2; m < 1000; m++)
	{
		s = 0;
		for (i = 1; i < m; i++)
			if ((m % i) == 0)
			{
				s = s + i;
			}
			if (s == m)
			{
				printf("%d,its factors are",m);
				for (i = 1; i < m; i++)
				{
					if (m % i == 0)
					 printf(" %d", i);
				}
					putchar('\n');			
			}
	}
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	/*double b = 1;*/
//	/*printf("%55.50f\n", b / 3);*/
//	int s;
//	scanf("%d",&s);0
//	printf("%d\n", s);
//
//	return 0;
//}

//
//int main(void)
//{
//	int m, n,min;
//	double s = 1;;
//	scanf("%d%d", &m, &n);
//	min = m * n;
//	while (s != 0)
//	{
//		s = fmod(m, n);
//		if (s != 0)
//		{
//			m = n;
//			n = s;
//
//		}
//	}
//	printf("the greatest common divisor = %d\n", n);
//	min = min / n;
//	printf("least common multiple = %d\n", min);
//
//	return 0;
//}

//int main(void)
//{
//	char c;
//	int letter = 0, space = 0, digit = 0, other = 0;
//	while ((c = getchar()) != '\n')
//	{
//		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')
//			letter++;
//		else if (c == ' ')
//			space++;
//		else if (c >= '0' || c <= '9')
//			digit++;
//		else
//			other++;
//		
//	}
//	printf("letter = %d ,space = %d\ndight = %d , other = %d\n", letter, space, digit, other);
//	return 0;
//}
//#define a 2
//int main(void)
//{
//	int n, sum = 0,flag=a;
//	
//	scanf("%d", &n);
//	while (n > 0)
//	{
//		sum = sum + flag;
//		flag = a + 10 * flag;
//		n--;
//	}
//	printf("sum = %d\n", sum);
//	return 0;
//}
int main(void)
{
	int n = 1, sum = 0, m = 1, mul = 1, top;
	scanf("%d", &top);
	while (n <= top)
	{
		sum = sum + mul;//1 
		n++;              //2
		for (m = 1,mul=1; m <= n; m++)mul = mul * m; //
	}
	printf("sum = %d\n", sum);
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	/*char c;
//	for (; (c = getchar()) != '\0'; c += 2)
//		printf("%c", c);*/
//	int i = 0;
//	int j = 0;
//	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
//
//	//int sz = sizeof(arr) / szieof(arr[0]);
//
//	
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0;j < 5; j++)
//		{
//			printf("%d  ", arr[i][j]);
//
//		}
//		putchar('\n');
//
//	}

	/*return 0;
}*/
//int main(void)
//{
//	int i, j, n=0;
//	for(i=1;i<=4;i++)
//		for (j = 1; j <= 5; j++, n++)
//		{
//			if (n % 5 == 0)printf("\n");
//			//if (i == 3 && j == 1)break;   break jump out of the loop	
//			//if (i == 3 && j == 1)continue; continue jump off once judge;   
//			printf("%d\t", j * i);
//		}
//
//
//
//	return 0;
//}
//int main(void)
//{
//	int sign = 1;
//	double  down, PI,term,n;
//	sign = 1.0;
//	down = 1.0;
//	PI = 0.0;
//	term = 1.0;
//	n = 1.0;
//	for (;n >1e-6; down += 2)
//	{
//		PI = PI + term;
//		sign = -sign;
//		n = fabs(PI);
//	}
//	printf("%f\n", PI);
//
//
//	return 0;
//}
//int main(void)
//{
//	int sign = 1;
//	double pi = 0.0, n = 1.0, term = 1.0;
//
//	while (fabs(term) >= 1e-6)
//	{
//		pi = pi + term;
//		n += 2;
//		sign = -sign;
//		term = sign / n;
//	}
//	pi = pi * 4;
//	printf("pi = %10.8f\n", pi);
//	return 0;
//}







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/int main(void)
//{
//	int num, flag, div, ten, hundred, thousand, ten_thousand, place;
//	top:
//	printf("enter num:");
//	scanf("%d", &num);
//	if (num > 9999 && num <= 99999)
//	{
//		flag = 5;
//	}
//	else if (num > 999 && num <= 9999)
//	{
//		flag = 4;
//	}
//	else if (num > 99 && num <= 999)
//	{
//		flag = 3;
//	}
//	else if (num >= 10 && num <= 99)
//	{
//		flag = 2;
//	}
//	else if (num >= 0 && num < 10)
//	{
//		flag = 1;
//	}
//	else
//	{
//		printf("wrong answer!\n");
//		goto top;
//	}
//	printf("the num has %d place\n", flag);
//
//	if (flag == 5)
//	{
//		ten_thousand = num / (pow(10, flag-1));
//		thousand = (num - ten_thousand * pow(10, flag - 1)) / pow(10, flag - 2);
//		hundred= (num - ten_thousand * pow(10, flag - 1)- thousand* pow(10, flag - 2))/ pow(10, flag - 3);
//		ten= (num - ten_thousand * pow(10, flag - 1) - thousand * pow(10, flag - 2)- hundred* pow(10, flag - 3)) / pow(10, flag - 4);
//		div = (num - ten_thousand * pow(10, flag - 1) - thousand * pow(10, flag - 2) - hundred * pow(10, flag - 3) - ten * pow(10, flag - 4))/ pow(10, flag - 5);;
//		printf("%d  %d  %d  %d  %d\n", ten_thousand, thousand, hundred, ten, div);
//		printf("turn opposited\n");
//		printf("%d  %d  %d  %d  %d\n",div,ten,hundred,thousand,ten_thousand);
//	}
//	else if (flag == 4)
//	{
//		
//		thousand = num  / pow(10, flag-1);
//		hundred = (num  - thousand * pow(10, flag-1 )) / pow(10, flag - 2);
//		ten = (num - thousand * pow(10, flag - 1) - hundred * pow(10, flag - 2)) / pow(10, flag - 3);
//		div = (num - thousand * pow(10, flag - 1) - hundred * pow(10, flag - 2) - ten * pow(10, flag - 3))/pow(10, flag - 4);
//		printf(" %d  %d  %d  %d\n", thousand, hundred, ten, div);
//		printf("turn opposited\n");
//		printf(" %d  %d  %d  %d\n", div, ten, hundred, thousand);
//	}
//	else if (flag == 3)
//	{
//		
//		hundred = num   / pow(10, flag-1 );
//		ten = (num - hundred * pow(10, flag - 1)) / pow(10, flag - 2);
//		div = (num - hundred * pow(10, flag - 1) - ten * pow(10, flag - 2)) / pow(10, flag - 3);;
//		printf("   %d  %d  %d\n",  hundred, ten, div);
//		printf("turn opposited\n");
//		printf("   %d  %d  %d\n",  div, ten, hundred);
//
//	}
//	else if (flag == 2)
//	{
//	
//		ten = (num ) / pow(10, flag-1 );
//		div = (num - ten * pow(10, flag - 1)) / pow(10, flag - 2);;
//		printf("   %d  %d\n",   ten, div);
//		printf("turn opposited\n");
//		printf("   %d  %d\n", div, ten);
//
//
//	}
//	else if (flag == 1)
//	{
//	
//		div = (num ) / pow(10, flag-1);;
//		printf("    %d\n",  div);
//		printf("turn opposited\n");
//		printf("    %d\n", div);
//
//	}
//	else
//	{
//		printf("wrong answer!\n");
//		goto top;
//	}
//
//
//	return 0;
//
//}

//reward system

//#define LEVE1 100000
//#define LEVE2 200000
//#define LEVE3 400000
//#define LEVE4 600000
//#define LEVE5 1000000
//int main(void)
//{
//	int x, flag, I, I1, I2, I3, I4, I5, I6;
//top:
//	printf("enter your profit : ");
//	scanf("%d", &x);
//
//	if (x >= 0 && x <= LEVE1)
//		flag = 1;
//	else if (x > LEVE1 && x <= LEVE2)
//		flag = 2;
//	else if (x > LEVE2 && x <= LEVE3)
//		flag = 3;
//	else if (x > LEVE3 && x <= LEVE4)
//		flag = 4;
//	else if (x > LEVE4 && x <= LEVE5)
//		flag = 5;
//	else if (x > LEVE4 )
//		flag = 6;
//	else
//	{
//		printf("wrong answer\n");
//		goto top;
//	}
//	I1 = x * 0.1;
//	I2 = I1 + (x - LEVE1) * 0.075;
//	I3 = I2 + (x - LEVE2) * 0.05;
//	I4 = I3 + (x - LEVE3) * 0.03;
//	I5 = I4 + (x - LEVE4) * 0.015;
//	I6 = I5 + (x - LEVE5) * 0.01;
//
//	switch (flag)
//	{
//	case 1:
//		I = I1;
//		break;
//	case 2:
//		I = I2;
//		break;
//	case 3:
//		I = I3;
//		break;
//	case 4:
//		I = I4;
//		break;
//	case 5:
//		I = I5;
//		break;
//	}
//	printf("According to your achievement,you can get %d in average \n", I);
//	goto top;
//	return 0;
//}

//int main(void)
//{
//	int a, b, c, d,max;
//	
//	scanf("%d%d%d%d", &a, &b, &c, &d);
//	max = d;
//	if (a > b && a > c && a > d)
//	{
//		max = a;
//	}
//	if (b > a && b > c && b > d)
//	{
//		max = b;
//	}
//	if (c > a && c > b && c > d)
//	{
//		max = c;
//
//	}
//	printf("max = %d\n", max);
//	return 0;
//}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//
//	printf("dsds");
//	return 0;
//}
//int main(void)
//{
//	int a = 10;
//	int b = log10(a);
//	int c = pow(a, 2);
//	printf("b = %d c =%d\n", b, c);
//
//	return 0;
//}
//int main(void)
//{
//	int a, b;
//	float x,y;
//	char c1, c2;
//	/*scanf("a=%db=%d", &a, &b);
//	printf("a=%d\t b=%d\n",a,b);*/
//	scanf("%f%e", &a, &y);
//	
//	printf("a=%d\ty=%e\n", a, y);//输入完71.82后应当直接输入Aa中间不能有空格 因为A为字符而非数字系统在独到A后自动判定给Y的值已结束
//	putchar('\n');
//
//	scanf("%c%c", &c1, &c2);
//	printf("c1=%c \tc2=%c\n",c1,c2);
//
//
//
//
//
//
//
//
//
//	return 0;
//}
//int main(void)
//{
//	char c1 = 'C', c2 = 'h', c3 = 'i', c4 = 'n', c5 = 'a';
//	int a = 4;
//	putchar(c1 + a); putchar(c2 + a); putchar(c3 + a); putchar(c4 + a); putchar(c5 + a);
//	putchar('\n');
//	printf("%c%c%c%c%c\n", c1 + a, c2 + a, c3 + a, c4 + a, c5 + a);
//
//	return 0;
//}
// 
//                                                           加密
//int main(void)
//{
//	int input = 1;
//	char c = 0;
//	int i = 0;
//	char arr[10] = {0 };
//	int n = 0;
//	while (input)
//	{
//		scanf("%c", &c);
//		getchar();
//		if (c != '0')
//		{
//			arr[i] = c;
//			i++;
//		}
//		else
//			input = 0;
//	}
//	for (n = 0; n < i; n++)
//	{
//		printf("%c", arr[n] + 4);
//	}
//	return 0;
//}

                                                         //解码
//int main(void)
//{
//	int input = 1;
//	char c = 0;
//	int i = 0;
//	char arr[] = { 0 };
//	int n = 0;
//	while (input)
//	{
//		scanf("%c", &c);
//		getchar();
//		if (c != '0')
//		{
//			arr[i] = c;
//			i++;
//		}
//		else
//			input = 0;
//	}
//	for (n = 0; n < i; n++)
//	{
//		printf("%c", arr[n] - 4);
//	}
//	return 0;
//}
//
//#define PI 3.1415
//int main(void)
//{
//    double C, S, Bs, Bv, Zv, r;
//    int h = 3;
//    r = 1.5;
//    C = PI * 2 * r;
//    S = PI * r * r;
//    Bs = 4.0 * PI * r * r;
//    Bv = 4.0/3.0 * PI*r*r*r ;
//    Zv = PI*r*r*h;
//    printf("perometer=%.2f\narea=%.2f\nsurface area of sphere=%.2f\nVolume of a sphere=%.2f\nVolume of a cylindrical=%.2f\n", C, S, Bs, Bv, Zv);
//
//int main(void)
//{
//    printf("%d\n", INT_MAX);
//    printf("%d\n", INT_MIN);
//
//
//    return 0;
//}
//int main(void)
//{
//    int a, b, c, max;
//    scanf("%d  %d  %d", &a, &b, &c);
//    if (a > b && a > c)
//        max = a;
//    if (b > a && b > c)
//        max = b;
//    else
//        max = c;
//    printf("max = %d\n", max);
//
//    return 0;
//}

//int main(void)
//{
//    int flag = 1;
//    int num=0;
//    do
//    {
//        scanf("%d", &num);
//        if (num < 1000 && num>0)
//        {
//            /*int tem = sqrt(num);*/
//            printf("%d", sqrt(num));//sqrt()求平方根  返回类型为double 需要用%f来接收
//            flag = 0;
//        }
//        else
//        {
//            printf("wrong answer,enter again\n");
//        }
//    
//    
//    } while (flag);
//
//    return 0;
//}

int main(void)
{
    int num = 9.0;
    printf("%d\n", sqrt(num));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	printf("hello\n");
//
//	return 0;
//}ik
//int main(void)
//{
//	double p = 1.0, r = 0.07;;
//	int n = 0;
//	while (n < 10)
//	{
//		p = p * (1 + r);
//		n++;
//
//	}
//	printf("increase %.3f times\n", p);
//	return 0;
//}
//int main(void)
//{
//	double p, r=0.07;
//	int n = 10;
//	p = pow(1 + r, n);
//	printf("p = %f\n", p);
//	return 0;
//}

//void menu(void)
//{
//	putchar('\n');
//	printf("*** 1 directly 5 years        ***\n");
//	printf("*** 2 2year first than 3      ***\n");
//	printf("****3 3year first than 2      ***\n");
//	printf("****4 one by one for 5year    ***\n");
//	printf("****5   live saving           ***\n");
//	putchar('\n');
//}
//
//int main(void)
//{
//	int input = 0,n=0;
//	double p = 1000.0, r = 0.0;
//	printf("we have five different choice for saving money: \n");
//	do
//	{
//		menu();
//		printf("what is your choice?:");
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 1:
//			n = 5;
//			r = 0.03;
//			p = 1000 * (1 + n * r);
//			break;
//		case 2:
//			n = 2;
//			r = 0.021;
//			p = 1000 * (1 + n * r);
//			n = 3;
//			r = 0.0275;
//			p = p * (1 + n * r);
//			break;
//		case 3:
//			n = 3;
//			r = 0.0275;
//			p = 1000 * (1 + n * r);
//			n = 2;
//			r = 0.021;
//			p = p * (1 + n * r);
//			break;
//		case 4:
//			n = 5; r = 0.015;
//			p = 1000 * pow(1 + r, n);
//			break;
//		case 5:
//			n = 5; r = 0.0035;
//			p = 1000 * pow((1 + r / 4), 4 * n);
//			break;
//		default:
//			printf("wrong answer \n");
//		}
//		printf("after 5 years , 1000 is %.2f now!\n", p);
//
//
//	} while (input);
//	return 0;
//}
int main(void)
{
	/*double d = 0.0, p = 0,r = 0.0;
	float m = 0, n = 0;;

	printf("how much did you get from the fucking bank : ");
	scanf("%f", &d);
	
	putchar('\n');
	printf("how much did you want  to pay each month : ");
	scanf("%f", &p);
	putchar('\n');
	printf("how about interest rate : ");
	scanf("%f", &r);
	putchar('\n');
	m = log10(p / (p - d * r))/ log10(1 + r);
	*/
	double a = 8.2;
	double s = log2(a);
	printf("s = %f", s);




	/*printf("you probably need %6.1f to pay back your debt!\n", m);*/
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	printf("int    = %5d \n", sizeof(int));
//	printf("float  = %5d \n", sizeof(float));
//	printf("double = %5d \n", sizeof(double));
//	printf("char   = %5d \n", sizeof(char));
//
//	return 0;
//}
//int main(void)
//{
//	int p = 1;
//	int q = 2;
//	do
//	{
//		p = p + q;
//		q = q + 1;
//
//
//	} while (q <= 100);
//	printf("total sum = %d\n ", p);
//	return 0;
//}

//int main(void)
//{
//	int  stus;
//	double money, ave, total;
//	ave = 0;
//	stus = 0;
//	money = 0;
//	total = 0;
//	for (stus = 1; stus < 1000; stus++)
//	{
//		printf("how much money do you want to denote : ");
//		scanf("%lf", &money);
//		total = total + money;
//	
//		if (total >= 100000)break;
//	}
//	ave = total / stus;
//	printf("there are %d students paying their money, and each one denote about %lf \$ in average\n",stus,ave);
//
//	return 0;
//}
//
//int main(void)
//{
//	int arr[4][5] = { {1,2,3,4,5},{2,4,6,8,10},{3,6,9,12,15},{4,8,12,16,20} };
//	int i = 0;
//	int j = 0;
//	for (i = 0; i <= 3; i++)
//	{
//		for (j = 0; j <= 4; j++)
//		{
//			printf("%4d  ", arr[i][j]);
//
//		}
//		putchar('\n');
//	}
//
//	return 0;
//}
//
//int main(void)
//{
//	double m = 0.0;
//	int i = 1;
//	double sum = 0.0;
//	double pi = 0.0;
//
//	for (m = 1.0; m < 1e6; m = m + 2)
//	{
//		sum =  (i / m)+sum ;//注意除法必须有一个浮点数 结果才能是浮点数
//		i = -i;
//
//
//	}
//	pi = sum * 4;
//	printf("pi = %.5lf\n", pi);
//
//	return 0;
//}
//int main(void)
//{
//	int sign = 1;
//	double pi = 0.0, n = 1.0, trem = 1.0;
//	while (fabs(trem) >= 1e-5)
//	{
//		pi = pi + trem;
//		n = n + 2;
//		sign = -sign;
//		trem = sign / n;
//	}
//	pi = pi * 4;
//	printf("pi = %.20f", pi);
//
//
//
//	return 0;
//}

//pi/4=1-1/3+1/5-1/7+........   ==> pi=4(1-1/3+1/5-1/7+........)
//int main(void)
//{
//	int sign;
//	double pi = 0.0, term = 1.0,n=1.0;
//	sign = 1;
//	n = 1;
//	while(fabs(term)>=1e-6)
//	{
//		pi = pi + term;
//		sign = -sign;
//		n = n + 2;
//		term = sign / n;
//
//	}
//	pi = pi * 4;
//	printf("pi = %.5f\n", pi);
//
//	return 0;
//}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//指向函数指针数组的指针
//int main(void)
//{
//	int arr[10] = { 0 };
//	int(*p)[10] = &arr;
//
//	int (*pfarr[4])(int, int);//函数指针数组
//	int (*(*ppfarr)[4])(int, int);//指向函数指针数组的指针
//	//ppfarr是一个数组指针，指针指向的数组有4个元素
//	//指向的数组的每个元素的类型是一个函数指针 int(*)(int,int)
//	return 0;
//}

//回调函数

void print(char* str)
{
	printf("hh:%s", str);
}
void test(void(*p)(char*))
{
	printf("test\n");
	p("bit");

}

int main(void)
{
	test(print);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//一维  数组传参和指针数组传参

//数组
//void test1(int arr1[]);
//void test1(int* arr);
//void test1(int arr[10]);
////指针数组
//void test2(int* arr2[20]);
//void test2(int* arr2[]);
//void test2(int** arr2);
//
//
//
//int main(void)
//{
//	int arr1[10] = { 0 };
//	int* arr2[20] = { 0 };
//
//	test1(arr1);
//	test2(arr2);
//
//
//	return 0;
//}

//二维数组传参
//void test(int arr[3][5])//直接用数组来接收
//{} 
//void test(int arr[][5])//行可以省略，列不能省略
//{}
//void test(int (*p)[5])//用数组指针接收  （*p）表示是一个指针，指向的是第1行的地址 [5]表示每一行对应多少元素  int 表示对应的元素是int类型
//{}
//
//int main(void)
//{
//	int arr1[3][5] = { 0 };
//
//	test(arr1);//此处的arr1代表首元素地址，但arr1是一个二维数组 故此时的首元素的地址是第一行的地址
//
//	return 0;
//}

//void test(int* p);//一级指针传参 用指针接收
//void test2(int* p1);
//int main(void)
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	test(p);
//
//
//	test2();//此处可以放变量地址，一维数组名，指针
//	return 0;
//}

//void test(int** p)//传参二级指针 用二级指针来接收
//{}
//
//int main(void)
//{
//	int a = 10;
//	int* p = &a;
//	int** pp = &p;
//	int* arr[10];
//	test(pp);//二级指针本身
//	test(&p);//一级指针的地址
//	test(arr);//指针数组的数组名
//
//	return 0;
//}

//数组指针  指向数组的指针
//函数指针  指向函数的指针


//int ADD(int x, int y)
//{
//	return x + y;
//}
//int main(void)
//{
//	int a = 10;
//	int b = 20;
//	//printf("%d\n",ADD(a,b));
//
//	//在函数指针中 &ADD=ADD 都是函数的地址
//	printf("%p\n", &ADD);//函数地址
//	printf("%p\n", ADD);
//
//	int (*pa)(int,int) = ADD;//函数指针
//
//	printf("%d\n", (*pa)(2, 3));//（*pa）是找到ADD函数 （2，3）进行传参 相当于 ADD(2,3)
//	return 0;
//}
void Print(char* str)
{
	printf("%s", str);
}

int main(void)
{
	void(*p)(char*) = Print;//(*p)必须要加括号 否则p就会先与后面的括号结合 导致整体是一个函数声明
	(*p)("adasdasf");
	return 0;
}
//
//int main(void)
//{
//	(*(void (*)())0)();
//	(void (*)())  这是一个类型 
//   (void (*)()) 0 强制类型转换 将0转换为一个函数指针类型 此时0就是一个函数的地址
// (*(void (*)())0)   加上* 进行解引用操作，调用0地址处的该函数 
//  (*(void (*)())0)() 找到了这个函数 传了一个空的参数 并开始运行这个函数
	//void (*signal(int, void(*)(int)))(int);

// signal是一个函数声明 
// 
// signal函数有两个参数 一个为int类型，一个为函数指针，这个函数指针 该函数指针指向的函数的参数为int类型，返回类型为void
// 
// signal 函数的返回类型为 函数指针 这个函数指针类型指向的函数的参数为int类型，返回类型为void
// 
//void  (*signal(int, void(*)(int)))  (int)  相当于 void (*    )(int) 是个函数指针类型
// 
// 	   也就是 signal(int, void(*)(int)是函数名 返回类型是void(*)(int)
	//如果一个函数的返回类型是一个函数指针 那不能写成 void(*)(int) signal(int, int) 而要写成 void (*  signal(int, int)  ) (int)

	//简化
//	typedef unsigned int uint;             //typedef 的一般使用方法
//
//	typedef void(*pfun_t)(int);            //typedef在定义函数指针时与一般不同，定义的新名字要放在 *后面 此处见pfun_t
//
//	pfun_t signal(int, pfun_t);            // 这两句=void (*signal(int, void(*)(int)))(int)
//	return 0;
//}
//int ADD(int x, int y)
//{
//	return x + y;
//}
//int SUB(int x, int y)
//{
//	return x - y;
//}
//int MUL(int x, int y)
//{
//	return x * y;
//}
//int DIV(int x, int y)
//{
//	return x / y;
//}
//int main(void)
//{
//	int a = 10;
//	int b = 20;
//	/*int(*p)(int,int) = ADD;*/
//
//	int(*parr[4])(int, int)={ADD,SUB,MUL,DIV};//函数指针数组 用来存放相同类型的函数类型的指针
//
//	int i = 0;
//	for (i = 0; i < 4; i++)
//	{
//		printf("%d\n",parr[i](6, 2));//函数指针调用时可以不解引用
//
//	}
//
//	//printf("%d\n", p(3,4));//这个*实际上可加可不加
//	//printf("%d\n", ADD(3, 4));
//	//printf("%d\n" ,(*p)(3,4));
//
//	return 0;
//}

//char* my_strcpy(char* dest, const char* src);
//
//int main(void)
//{
//	char*(*pf)(char*, const char*) = my_strcpy;
//	char* (*pfArr[4])(char*, const char*);
//	return 0;
//}

//函数指针数组的应用  
//计算器程序
void menu()
{
	printf("***************************************\n");
	printf("***      1 ADD        2 SUB  **********\n");
	printf("****     3 MUL        4 DIV   *********\n");
	printf("******         0  EXIT      ***********\n");
	printf("***************************************\n");

}

int ADD(int x, int y)
{
	return x + y;
}
int SUB(int x, int y)
{
	return x - y;
}
int MUL(int x, int y)
{
	return x * y;
}
int DIV(int x, int y)
{
	return x / y;
}
int main(void)
{
	int input = 0;
	int num1 = 0;
	int num2 = 0;
	//函数指针数组  -- 转移表
	int(*pf[])(int, int) = {0,ADD,SUB,MUL,DIV};
	do
	{

		menu();
		printf("Please enter your choice:");
		scanf("%d", &input);
		if (input >= 1 && input <= 4)
		{
			printf("Please enter two number:");
			scanf("%d%d", &num1, &num2);
			printf("%d\n", pf[input](num1, num2));
		}
		else if (input == 0)
		{
			printf("EXIT\n");
		}
		else
			printf("Wrong answer,enter again later\n");

	}while(input);
	return 0;
}
//int main(void)
//{
//	int input = 0;
//	int num1 = 0;
//	int num2 = 0;
//	do
//	{
//		
//		menu();
//		printf("Please enter your choice:");
//		scanf("%d", &input);
//			
//		switch (input)
//		{
//		case 1:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("ADD=%d\n",ADD(num1, num2));
//			break;
//		case 2:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("SUB=%d\n", SUB(num1, num2));
//			break;
//		case 3:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("MUL=%d\n", MUL(num1, num2));
//			break;
//		case 4:
//			printf("Please enter two number:");
//			scanf("%d%d", &num1, &num2);
//			printf("DIV=%d\n", DIV(num1, num2));
//			break;
//		case 0:
//			printf("EXIT");
//			break;
//		default:
//			printf("wrong answer,enter again\n");
//			break;
//		}
//			
//	} while (input);
//
//	return 0;
//}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	char* p = "asdasdasd";//stable array (unchangeble data)
//	//actualy  the location of the first char(a) was saved by p(pinter)
//	printf("%c\n", *p);
//	printf("%s\n", p);
//
//	return 0;
//}

//int main(void)
//{
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	const char* p = "abcdef";
//	const char* p1 = "abcdef"; //constant 
//
//	if (p == p1)
//	{
//		printf("hehe\n");
//	}
//	else
//		printf("haha\n");
//



	/*printf("%p\n", arr1);
	printf("%p\n", arr2);*/
	//if (arr1 == arr2)  //this means the location of the first charaster
	//{
	//	printf("hehe\n");
	//}
	//else
	//	printf("haha\n"); //it is different between the location of the first charaster of arr1 and arr2

//	return 0;
//}

//指针数组  存放指针变量的数组
//int main(void)
//{
//	//int arr[10] = { 0 };//整型数组
//	//int* prr[4];//存放整型指针的数组
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	int d = 40;
//	int* prr[4] = { &a,&b,&c,&d };   //指针数组的使用
//	//printf("%d", *prr[0]);
//	int i = 0;
//	for (i = 0; i < 4; i++)
//	{
//		printf("%d ", *(prr[i]));
//
//	}
//	return 0;
//}
// 
// 
//指针数组主要用法
//int main(void)
//{
//	int arr1[] = { 1,2,9,4,5 };
//	int arr2[] = { 2,3,4,5,6 };
//	int arr3[] = { 3,4,5,6,7 };
//
//	int* parr[] = { arr1,arr2,arr3 };
//
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//	
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d  ", *(parr[i]+j));
//		}
//		
//		printf("\n");
//	}
//
//
//	return 0;
//}

//数组指针  指针
//int main(void)
//{
//	int* pd = 10; //整型指针————指向整型的指针————可以存放整型的地址
//	char* pc = 'w';//字符指针————指向字符的指针————可以存放字符的地址
//	              //数组指针————指向数组的指针——————可以存放数组的地址
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//     //arr 数组名 表示首元素的地址
//	//&arr 表示数组的地址
//	int(*parr)[10] = &arr;   //parr就是数组指针
//
//	//WRONG int* parr[10]=&arr 因为数组的优先级要比指针高，此处的parr表达的是一个指针数组
//
//	return 0;
//}
//int main(void)
//{
//	char* arr[5];
//	char*(*p)[5] = &arr;// 数组指针的格式：    数组类型 (*指针名) [元素个数] =&数组名
//
//	int arr1[10] = { 0 };
//	int (*pa)[10] = &arr1;
//	return 0;
//}

//int main(void)
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	/*int(*p)[10] = &arr;
//	int i = 0;*/
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d  ", *(p + i));
//	}
//	//数组指针这么用会很麻烦
//	//exp1
//	//for (i = 0; i < 10; i++)
//	//{
//	//	printf("%d ", (*p)[i]);//此处的*p其实为数组名
//	//}
//	//exp2
//	 //for (i = 0; i < 10; i++)
//	//{
//	//  printf("%d ", *(*p + i));//*p==arr
//	//}
//	return 0;
//}

void print1(int arr[3][5], int x, int y)//数组接收arr
{
	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 5; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}

void print2(int(*p)[5], int x, int y)  //此处要将arr想象为一维数组 
{
	int i = 0;
	for (i = 0; i < x; i++)
	{
		int j = 0;
		for (j = 0; j < y; j++)
		{
			printf("%d ", p[i][j]);
			//printf("%d  ", *(*(p + i) + j)); //p+i会直接跳过一行应为p存储的每一个元素为1行 加上j找到第p+i行的元素 再解引用得到这个元素
			//printf("%d  ", (*(p + i))[j]); //*(p)表示一整行的元素+i跳过这一行

		}
		printf("\n");

	}


}

int main(void)
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	//print1(arr,3,5);
	print2(arr,3,5);//arr为首元素地址 传参的时候 可以用数组接收 或指针接收
	//int arr[] = { 1,2,3,4,5 };
	//int* p = arr; //实际上p就是arr
	//int i = 0;
	//for (i = 0; i < 5; i++)
	//{
	//	//printf("%d ", *(p + i));
	//	//printf("%d ", *(arr + i));
	//	printf("%d ", p[i]);                                  arr[i]=*(arr+i)= *(p+i)= p[i]
	//	
	/*}*/


	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//void test(int arr[])//需要用指针变量或数组来接收实参
//{
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//64位的指针变量为 8个字节  32位为4个字节
//	//因为此处arr的元素为int类型 及占据4个字节 故此处为8/4=2
//	printf("size = %d\n",sz);
//}
//
//int main(void)
//{
//	int arr[10] = { 0 };
//
//	test(arr);//传过去的是首元素地址
//
//	return 0;
//}
//

//int main(void)
//{
//	char arr[] = "qweqwr";
//
//	char* pc=arr;
//	printf("%s\n", arr);
//	printf("%s\n",pc);
//	return 0;
//}

int main(void)
{
	const char* pc = "asdhaweqwdr";//"asdhaweqwdr"此处是在内存中创建了一个常量字符串
	//加const进一步保护代码
	*pc = 'w';//常量字符串是无法被改变的
	printf("%s\n", pc);

	//pc指针变量是指向常量字符串的首元素地址a
	//printf("%c\n",*pc);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main(void)
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i); 9 8 7 6 5 4 3 2 1 0 Unisgned_int_max ---  无限循环
//		Sleep(100);
//	}
//	return 0;
//}

//int main(void)
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d\n",strlen(a));
//	//-1 ------> -128 -->127 --------->3,2,1,0
//	//128+127 =  255  stelen() end by  '\0'=0
//	return 0;
//}

//int main(void)
//{
//	unsigned char i = 0;
//	int count = 0;
//	//unsigned char :[0,255]                   always true
//	for (i = 0; i <= 255; i++)//               loop 225+1=0
//	{
//		printf("duck duck\n");
//		count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}
int main()
{

（-1)^S*M*2^E 浮点形数据在内存中的存储规则
	//float type store
	//v=(-1)^S*M*2^E   
	//S--- V正数S=0；V负数S=1
	//M---有效数字，大于等于1，小于2 [1,2)
	//2^E 指数位 E(unsigned int) 存入内存时 E的真实值必须加上中间值  8位存储时+127  （double)11位存储时+1023

	//9.0
	//1001.0
	//(-1)^0*1.001*2^3  此处的1.001实际上只存储了 .001 等拿出来时会补上1

	//0.5
	//0.1  2^-1
	//(-1)^0 * 1.0 * 2^-1
	//S= 0
	//M= 1.0
	//E=-1  =(float)(32位浮点数8位存储E时）     E+127=126 实际-1存储的是126
	//      =(double)（64位的浮点数11位存储E时） E+1023=1022 实际的-1存储的是1022




	int n = 9;
	//00000000 00000000 00000000 00001001----- 9的二进制补码
	float*p=(float*)& n;
	printf("n= %d\n", n);//9
	printf("p=%f\n", *p);//0 00000000  00000000000000000001001  (-1)^0 * 0.00000000000000000001001 * 2^-126 ->0

	*p = 9.0;
	//1001.0     
	//(-1)^0 * 1.001 * 2^3    
	//0 10000100 00100000000000000000000
	printf("n = %d\n", n); //2^31+2^26+2^23
	printf("*p=%f\n", *p); //(-1)^0*1.001*2^3=9.0


	return 0;
}

//int main()
//{
//	float f = 5.5;//0X40b00000
//	//00 00 b0 40  小端存储  两个两个一拿
//
//
//	return 0;
//}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int check_sys()
//{
//	int a = 1;
//	//char* p = &a;
//	/*if (*p == 1)
//		return 1;
//	else
//		return 0;*/
//	//return 1 little
//	//return 0 big
//
//	//return *p;
//
//	return *(char*)&a;
//	
//	//指针类型的意义
//	//1 指针类型决定了解引用操作能访问的字节数 char* 1个字节  int* 4个字节
//	//2 指针类型决定了指针+1 -1  加的或减的是几个字节 char*p p+1跳过一个字节  int*p  p+1跳过4个字节
//
//}
//
//int main(void)
//{
//	//判断本机存储字序方式
//
//	/*int a = 999999999999999999;
//
//	char* p = (char*) & a;
//	if (*p != 0)
//	{
//		printf("small\n");
//	}
//	else
//		printf("big\n");*/
//	//return 1 little
//	//return 0  big
//	int ret = check_sys();
//	if (ret == 1)
//		printf("littel\n");
//	else if (ret == 0)
//		printf("big\n");
//	else
//		printf("wrong\n");
//
//
//
//	return 0;
//}

//int main(void)
//{
//	int a = 0x11223344;
//	/*int* pd = &a;
//	*pd = 0;*/
//	char* pc = &a;
//	*pc = 0;
//	printf("%d\n", a);
//	return 0;
//}





int main(void)
{
	char a = -128;
	signed char b = -1;
	unsigned char c = -128;
	//10000000000000000000000000000001
	//11111111111111111111111111111110
	//11111111111111111111111111111111
	//由于定义的是char类型 打印的是int类型 打印时需要对补码先进行整型提升
	// 
	// 发生截断时 最后截断的数据是根据本机储存形式来确定 是      大端存储（截断前面）         还是小端存储（截断后面）
	// 
	// 整型提升是更具当前数据储存变量来决定 有符号（扩充符号位） 无符号（扩充0）
	//a 11111111  -》》 11111111111111111111111111111111   -----》10000000000000000000000000000001   -----》-1
	//b 11111111  -》》 11111111111111111111111111111111   -----》10000000000000000000000000000001   -----》-1
	//c 11111111 ---->  00000000000000000000000011111111-------->00000000000000000000000011111111(z正数原反补相同 --------》255


	unsigned char d = 255;
	printf("%u %d %d ", a, b, c);

	return 0;
}


//-128  10000000000000000000000010000000----
//      11111111111111111111111101111111
//      11111111111111111111111110000000
//      11111111111111111111111110000000 整型提升 char a = -128(有符号）
//     011111111111111111111111110000000  %u unsigned int 因为要求无符号 所以第一个1不再是符号位  4,294,967,168
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int main()
//{
//	int i = 0;
//	int count = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	printf("%p\n", arr);
//	printf("%p\n", &i);
//	printf("%p\n", &count);
//	
//	system("pause");
//	for (i = 0; i <= 12; i++)
//	{
//		printf("hhe\n");
//		arr[i] = 0;   //当i>=10 时 就会出现非法访问
//		count++;
//
//	}
//	//printf("count = %d \n", count);
//	
//	return 0;
//}
//栈区根据地址的大小 分为高地址和低地址 
//栈区的默认使用规则是 先使用高地址，在使用低地址
//数组在内存中是连续存放的 随着小标的增长 由低到高进行储存

//创建的局部变量是放在栈上的 栈区是由高到低进行储存 故i 的地址比arr数组要高且随着数组下表的变大 地址会由低到高变化 故当arr数组越界访问时 可能会和i的地址重复 此时就会引发死循环
//Release 有优化变量存储结构的功能


//void my_strcpy(char* dest, char* src)
//{
//	while (*src != '\0')
//	{
//		*dest = *src;
//		src++;
//		dest++;
//	}
//	*dest = *src;
//}

//void my_strcpy(char* dest, char* src)
//{
//	while (*src != '\0')
//	{
//		*dest++ = *src++;
//		
//	}
//	*dest = *src;
//}

//void my_strcpy(char* dest, char* src)
//{
//	while (*dest++ = *src++)
//	{
//		;
//
//	}
//	
//}
//void my_strcpy(char* dest, char* src)
//{
//	if (dest != NULL && src != NULL)
//	{
//		while (*dest++ = *src++)
//		{
//			;
//
//		}
//	}
//	
//
//}

//char* my_strcpy(char* dest, const char* src)  //此处加const可以确保拷贝对象的不被改变
//{
//	char* ret = dest; 
//	assert(dest != NULL);
//	assert(src  != NULL);//include<assert.h>
//	//将src指向的字符串拷贝到dest指向的空间 包含'\0'字符
//		while (*dest++ = *src++)
//		{
//			;
//		}
//		return ret; //此处如果return dest  (ERR) 此地址已经改变 故需要建立一个零时指针变量 用来存储最初的dest指针地址
//}
//
//int main()
//{
//	char arr[] = "################";
//	char arr2[] = "bit";
//	
//
//	printf("%s\n", my_strcpy(arr, arr2));//链式访问 返回值最为另一个函数的参数
//	return 0;
//}

//int main()
//{
//	const int num = 10;//此处若建立指针变量，仍然可以修改
//
//	const int* p =&num; //const放在指针类型的左边 修饰的是*p  此时不能通过p来修饰*p（num)的值
//	//int* const p =&num; const 放在指针类型的右边， 修饰的是p 等于给指针变量p赋予了常属性 此时不能在改变指针变量p所指向的地址
//	*p = 20;
//	
//
//	printf("%d\n", num);
//	return 0;
//}
//


//int my_strlen(const char* arr)
//{
//	assert(arr != NULL);
//	int count = 0;
//	while (*arr != '\0')
//	{
//		count++;
//		
//		arr++;
//	}
//	return count;
//}
//
//
//int main()
//{
//	char arr[] = "qwejqwe";
//
//	int len = my_strlen(arr);
//
//	printf("length = %d \n", len);
//	return 0;
//}


//int main()
//{
//	int a = 10;    //0a 00 00 00 d3 8e d6 6e f8
//	float b = 10.0;//00 00 20 41 00 00 00 00 00
//	//不同类型存储方式之间的不同
//	//1 开辟的空间大小不同
//	//2 存储方式不同
//	return 0;
//}

//void test(void)//没有定义形式参数来接收实参时 直接忽略实参
//{
//
//	printf("hehe\n");
//}
//int main()
//{
//	int a = -8;
//
//	return 0;
//}


//整型在内存中的存储方式 -----二进制补码
                            // 负数
// 显示的是原码             eg:-8      10000000000000000000000000001000
// 原码按位取反得到反码      eg:-8      11111111111111111111111111110111
// 反码+1得到补码           eg:-8      1111 1111 1111 1111 1111 1111 1111 1000    
                                   // F     F    F   F    F    F    F    8     0xFFFFFFFF8   f8 ff ff ff 00 00 00 00 00(小端存储模式）
//大端存储模式 ---低位放在高地址，高位放在低地址
//小端存储模式 ---低位放在低地址，高位放在高地址
// 从左到右 越来越大
// 低位---------------------------高位
// 0xFFFFFFFF8  F8为低位  
// 
// 
// 
            //正数 （原，反，补码相同）
//原码   eg:8    00000000000000000000000000001000
//反码           00000000000000000000000000001000
//补码           00000000000000000000000000001000


//CPU只有加法  补码进行运算
//EG： 1-1  =》1+（-1）
//00000000000000000000000000000001   1
//11111111111111111111111111111111  -1
//00000000000000000000000000000000   0







///////////////////////////////////////////////////////////////////
//int main()
//{
//	int i = 0;
//	for (i = 0; i < 20; i++)
//	{
//		printf("%d  ", i);
//	}
//	system("pause");
//	return 0;
//}
//
//
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int i = 0;
//	for (i = 0; i <= 12; i++)
//	{
//		printf("hehe\n");
//		arr[i] = 0;
//	}
//	system("pause");
//
//	return 0;
//}


//设置断点  F9 配和 F5一起使用
//int main()
//{
//	int i = 0;
//	for (i = 0; i < 100; i++)
//	{
//		printf("%d ", i);
//	}
//
//	for (i = 0; i < 100; i++)
//	{
//		printf("%d ", 10-i);
//	}
//
//	
//	return 0;
//}

//int ADD(int x, int y)
//{
//	return x + y;
//}
//
//int main()
//{
//	printf("hehe\n");
//	int i = 0;
//	int b = 10;
//	int c = ADD(i, b);
//	printf("%d \n", c);
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i;
//		printf("%d \n", arr[i]);
//	}
//
//	return 0;
//}
//void test2()
//{
//	printf("fuck you \n");
//}
//
//void test1()
//{
//	test2();
//}
//void test()
//{
//	test1();
//}
//int main()
//{
//
//	test();
//	return 0;
//}


//typedef struct ASS
//{
//	char name[20];
//	int age;
//	char sex[10];
//}ASS;
//
//
//
//void print1(ASS* p)
//{
//	printf("name :  %s\n", p->name);
//	printf("age  :  %d\n", p->age);
//	printf("sex  :  %s\n", p->sex);
//
//}
//
//void print2(ASS p)
//{
//	printf("name :  %s\n", p.name);
//	printf("age  :  %d\n", p.age);
//    printf("sex  :  %s\n", p.sex);
//
//}
//int main()
//{
//	ASS s = { "frank",20,"male" };
//	print1(&s);
//	print2(s);
//	return 0;
//}
//	

//1!+2!+3!+...+n!

int main()
{
	int n = 0;//enter the final number!
	int sum = 0;//the final answer
	int i = 0;//the number of 1 to n
	int x = 0;//the n!
	int y = 1;
	printf("Please enter the number you want :  ");
	scanf("%d", &n);
	for (i = 1; i <= n; i++)
	{
		y = 1;
		for (x = 1; x <= i; x++)
		{
			y = x * y;
		}
		sum = sum + y;

	}
	printf("%d \n", sum);

}


int main()
{
	int i = 0;
	int sum = 0;
	int n = 0;
	int ret = 1;
	scanf("%d", &n);
	for (i = 1; i <= n; i++)
	{
		int j = 0;
		ret = 1;//ret 需要初始化
		for (j = 1; j <= i; j++)
		{
			ret *= j;
		}
		sum += ret;
	}
	printf("%d\n", sum);

	return 0;
}


////////////////////////////////////////////////////////////////////////////////////
// .c文件通过编译变为可执行文件  .exe
//debug 文件 即调试文件 的调试可执行文件 包含了调试信息
//release 发行文件不会包含可调试文件，因此会比debug文件要小




int main()
{
	int i = 10;
	for (i = 10; i < 20; i++)
	{
		printf("%d  ", i);
	}
	system("pause"); //使得直接使用debug文件时，cmd可以停留在桌面#inuclude<stdlib.h>
	return 0;
}







//typedef struct Stu
//{
//	char name[20];
//	char tele[12];
//	short age;
//	char sex[8];
//}Stu;
// 
//void print2(Stu tmp) 传值  会导致压栈 在时间和空间上都逊色与传址
//{
//	printf("name : %s\n", tmp.name);
//	printf("tele : %s\n", tmp.tele);
//	printf("age  : %d\n", tmp.age);
//	printf("sex  : %s\n", tmp.sex);
//	
//}
//void print1(Stu* tmp)   传址  不会压栈 节省计算机资源 
//{
//	printf("name : %s\n", tmp->name);
//	printf("tele : %s\n", tmp->tele);
//	printf("age  : %d\n", tmp->age);
//	printf("sex  : %s\n", tmp->sex);
//	printf("\n");
//}
//
//int main()
//{
//	Stu s1 = {"Frank","13552868009",20,"male"};
//
//	print1(&s1);//传址最佳
//	print2(s1); //传值次之
//
//	return 0;
//}




//struct S
//{
//	int a;
//	char arr[20];
//	double f;
//};
//
//struct T
//{
//	char ch[10];
//	struct S s;
//	char* p;
//};
//
//int main()
//{
//	char arr[20] = "fuck you up";
//	struct T t = { "frank",{66,"hello",3.14},arr };
//
//	printf("%s\n", t.ch);
//	printf("%lf\n", t.s.f);
//	printf("%s\n", t.p);
//
//	return 0;
//}
//








/////////////////////////
#pragma once

#define ROW 3
#define COL 3

#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//function naming
void InitBoard(char board[ROW][COL], int row, int col);

//surface
void DisplayBoard(char board[ROW][COL], int row, int col);

//playing
void Playermove(char board[ROW][COL], int row, int col);

void Computermove(char board[ROW][COL], int row, int col);

//judging have four situations
//player win   ---'*'
// computer win ---'#'
// no winner   ----'Q'
//continue ----'C'

char judge(char board[ROW][COL], int row, int col);

///////////////////////////////game.c
#include"game.h"


//function creating
void InitBoard(char board[ROW][COL], int row, int col)
{
	int i =0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			board[i][j] = ' ';

		}
	}

}

void DisplayBoard(char board[ROW][COL], int row, int col)
{
	int i = 0;
	 
	for (i = 0; i < row; i++)
	{
		/*printf(" %c | %c | %c\n",board[i][0],board[i][1],board[i][2]);*/
		int j = 0;
		for (j = 0; j < col; j++)
		{
			printf(" %c ", board[i][j]);
			if(j<col-1)
			printf("|");

		}
		printf("\n");

		if (i < row - 1)
		{
			for (j = 0; j < col; j++)
			{
				printf("---");
				if(j<col-1)
				printf("|");
			}
			printf("\n");
		}		
	}
}


void Playermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("It is your time \n");
	
	while (1)
	{
		printf("Enter the location you want : ");
		scanf("%d%d", &x, &y);
		//Are this two number possible?
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (board[x - 1][y - 1] ==' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
			{
				printf("this position has been occupied\n");
			}

		}
		else
		{
			printf("It is not excited,Enter again! \n");

		}


	}
}


void Computermove(char board[ROW][COL], int row, int col)
{
	printf("NPC moving : \n");
	int x = 0;
	int y = 0;
	while (1)
	{
		x = rand() % row;
		y = rand() % col;
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}	
}


// 1 full
// 0 Not full

int isfull(char board[ROW][COL], int row, int col)
{
	int i = 0;

	for (i = 0; i < row; i++)
	{
		int j = 0;
		for (j = 0; j < col; j++)
		{
			if (board[i][j] == ' ')
				return 0;
		}

	}
	return 1;
}


char judge(char board[ROW][COL], int row, int col)
{
	int i = 0;
	for (i = 0; i < row; i++)
	{
		if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][1] != ' ')
			return board[i][1];
	}
	for (i = 0; i < col; i++)
	{
		if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[1][i] != ' ')
			return board[0][i];
	}
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[1][1] != ' ')
		return board[0][0];
	if (board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[1][1] != ' ')
		return board[1][1];

	// no winner
	if (1 == isfull(board,ROW,COL))
	{
		return 'Q';
	}
	else
	 return 'C';
}


//////////////////////////////              test.c
#include<stdio.h>
#include"game.h"


void menu()
{
	printf("***********************\n");
	printf("****1 play  0 quit*****\n");
	printf("***********************\n");
}
//the creating of this game
void game()
{
	char ret = 0;
	printf("\nThree Word Chess \n");
	//creating a arrat to store the input data
	char board[ROW][COL]= {0};//we need a empty array
	// Renew the chess board
	InitBoard(board,ROW,COL);
	//print the surface
	DisplayBoard(board, ROW, COL);
	//playing the game
	while (1)
	{
		//player
		Playermove(board,ROW,COL);
		DisplayBoard(board, ROW, COL);
		//  who win?
		ret = judge(board, ROW, COL);
		if (ret != 'C')
		{
			break;
		}
		//computer
		Computermove(board, ROW, COL);
		DisplayBoard(board, ROW, COL);
		// who win?
		ret = judge(board, ROW, COL);
		if (ret != 'C')
		{
			break;
		}
		
	}
	if (ret == '*')
	{
		printf("you win \n");
	}
	else if (ret == '#')
	{
		printf("you lose the game\n");
	}
	else
	{
		printf("there is no winner \n");
	}
}

void text()
{
	int input = 0;
	srand((unsigned int)time(NULL));//only use one time 
	do
	{
		menu();
		printf("Please enter your choice :  ");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();

			break;
		case 0:

			printf("Quitting the game now \n");
			break;
		default:
			printf("\nWrong answer, please enter again\n");
			break;

		}

	} while (input);


}



int main(void)
{
	text();

	return 0;
}











//////////////////////game.h (searching mine)
#pragma once
#include<stdio.h>
#include<time.h>
#include<stdlib.h>
#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define Mines 80

void InitBoard(char board[ROWS][COLS],int rows,int cols,char set);

void DisplayBoard(char board[ROWS][COLS], int row, int col);

void SetMine(char board[ROWS][COLS], int row, int col);

void DetectMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);


///////////////////game.c
#include"game.h"


void InitBoard(char board[ROWS][COLS], int rows, int cols,char set)
{
	int i = 0;
	int j = 0;
	
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i <= col; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ",i);
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}

void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = Mines;
	while (count)
	{
		int x = rand() % row+1;
		int y = rand() % col+1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}
//a ,b is the char number
//'a'+'b'=a+b(number)
//'a'+'0'=a(number)

int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y] +
		mine[x - 1][y - 1] +
		mine[x][y - 1] +
		mine[x + 1][y - 1] +
		mine[x + 1][y] +
		mine[x + 1][y + 1] +
		mine[x][y + 1] +
		mine[x - 1][y + 1] - 8 * '0';


}

void DetectMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	
	while (win<row*col- Mines)
	{
		printf("Please enter the site you want(with a space in the middle) : ");
		scanf("%d%d", &x, &y);
		//whether this shit illigal?
		//1 dead
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (mine[x][y] == '1')
			{
				printf("saddly, you dead \n");
				DisplayBoard(mine, row, col);
				break;
			}
			else//continue or win
			{
				//conut the number of mines surrounding the site
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("Wrong answer,trt again later\n");

		}
	}
	if (win == row * col - Mines)
	{
		printf("you win!!!\n");
		DisplayBoard(mine, row, col);
	}
}
/////////////test.c

#include"game.h"
void menu()
{
	printf("*******************************\n");
	printf("****1   Play     0  Quit*******\n");
	printf("*******************************\n");
}

void game()
{
	//data storing
	//1 Settle mine  data
	char mine[ROWS][COLS] = { 0 };
	//2 Detect mine data
	char show[ROWS][COLS] = { 0 };
	//3 Renew the board
	InitBoard(mine, ROWS, COLS,'0');
	InitBoard(show, ROWS, COLS,'*');
	//the surface
	//DisplayBoard(mine,ROW,COL);
	DisplayBoard(show,ROW,COL);
	// set the mine
	SetMine(mine,ROW,COL);
	DisplayBoard(mine, ROW, COL);
	//detect the min
	DetectMine(mine,show,ROW,COL);
	
}
void test()
{
	int input = 0;	
	srand((unsigned int)time(NULL));
	do
	{
		menu();
		printf("Please enter your choice :  ");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("Quitting the game now \n");
			break;
		default:
			printf("Wrong answer,Check the number and enter again\n");
			break;
	    }
	} while (input);

}
int main(void)
{

	test();

	return 0;
}












/////////////////////////////////////////////////////////////

int main(void)
{
	int arr[] = { 1,2,3,4,57,889 };
	printf("%p \n", arr);//数组名及首元素地址
	printf("%p \n", &arr[0]);
	printf("%d \n", *arr);//就是首元素的地址
	return 0;
}
例外情况（数组名不代表首元素地址）
1 sizeof(数组名)，此时数组名标准整个数组，求得整个数组的大小
2 &arr 取地址数组名，取出的是整个数组的地址


///////////////////////////////////////////////////////////////
算术左移，相当x2 的效果
int main(void)
{
	int a = 9;
	int b = a << 1;
	printf("%d \n", b);
	//左边丢弃，右边补0 符号位不变

	return 0;
}


移位操作符 ——算术右移位，，右移移位相当于除2 的效果
int main(void)
{
	int a = -8;
	int b = a >> 2;
	printf("%d \n", b);
	printf("%p \n", &a);
	//10000000000000000000000000001000  -8
	//10000000000000000000000000000100  -4
	return 0;
}

/////////////////////////////////////////////////////////////

int main(void)
{
	int a = 3;//00000000000000000000000000000011
	int b = 5;//00000000000000000000000000000101
	int c = a & b;//按位与 有一个0 就为0 两个都为1  才为1  00000000000000000000000000000001  1
	int d = a | b;//按位或 有一个为1则为1 两个都为0 才为0  00000000000000000000000000000111 7
	int e = a ^ b;//按位异或  相同为0 相异为1 00000000000000000000000000000110 6

	printf("%d \n", c);//1
	printf("%d \n", d);//7
	printf("%d \n", e);//6
	return 0;

//////////////////////////////////////////////////////
int main()
{
	int a = 0;
	printf("%d\n", ~a);
	//~按（二进制）位取反
	//a
	//00000000000000000000000000000000 正数的原反补码相同
	//11111111111111111111111111111111-补码 storage
	//11111111111111111111111111111110-反码
	//10000000000000000000000000000001-原码 surface  -1
	return 0;
}


//////////////////////////////////////////////////


int main()
{
	int i = 0;
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	//i = a++ && ++b && d++;//逻辑与  只要遇到一个0 直到遇到0 那么后面不管是什么，忽略 1，2，3，4
	//i = a++ || ++b || d++; //1，3，3，4 逻辑或，只要遇到一个真 那么后面不管是什么 直到遇到一个真，忽略
	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);

	return 0;
}

////////////////////////////////////////////////////
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int max = (a > b ? a : b);//三目操作符
	printf("max = %d \n", max);


	return 0;
}


////////////////////////////////////////////
野指针
//临时变量出test函数后就销毁了 
int* test()
{
	int a = 10;
	return &a;
}

//*p 由于原来的地址已经销毁，故为野指针
int main()
{
	int* p =test();

	printf("%d\n", *p);
	return 0;
}
///////////////////////////////////////////
int main()
{
	//指针-指针，两个指针必须指向同一个空间
	char ch[5] = { 0 };
	int a[10] = {99,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", &a[9] - &a[0]);//指针-指针得到的是中间的元素个数；
	printf("%d\n", &a[0] - &a[9]);
	printf("%d\n", &a[9] - &ch[4]);//Wrong

	return 0;
}
/////////////////////////////
[Using point to explain strlen]
int My_strlen(char* str)
{
	char* start = str;
	char* end = str;
	while (*end != '\0')
	{
		end++;
	}
	return end - start;

}

int main(void)
{
	char arr[] = "Fuck you up";
	int len = My_strlen(arr);
	printf("%d\n", len);

	return 0;
}

///////////////////////////////////////////
struct Stu
{
	char name[20];
	short age;
	char sex[5];
}Stu; // 此处的Stu是全局变量

typedef struct Stu  //typedef 重新取个名字
{
	char name[20];
	short age;
	char sex[5];
}Stu;//重新取得名字  此处的stu是类型 而不是全局变量 =（int folat char...)


int main(void)
{
	struct Stu s = { "Frank",20,"male" };
	Stu s1;
	printf("%s\n", s);

	return 0;
}

////////////////////////////////////////////
struct S
{
	int age;
	char arr[20];
	double c;

};

struct T
{
	char ch[20];
	struct S s;
	char* p;

};

int main(void)
{
	char arr[60] = "Never gonna give you up";
	struct T t = { "hehe",{20,"aosijd",2.7},arr};//嵌套结构体

	//打印结构体内部对象 结构体名.对象
	printf("%s\n", t.ch);
	printf("%d\n", t.s.age);
	printf("%s\n", t.s.arr);

	return 0;
}

////////////////////////////////////////////////////////////
typedef struct Stu
{
	char name[29];
	short age;
	char tele[20];
}Stu;
void print1(Stu tmp)
{
	printf("name = %s\n", tmp.name);
	printf("age = %d\n", tmp.age);
	printf("tele = %s\n", tmp.tele);
}
//结构体指针
void print2(Stu* ps)
{
	printf("name = %s\n", ps->name);  //结构体指针->结构体成员
	printf("age = %d\n", ps->age);
	printf("tele = %s\n", ps->tele);
}
int main()
{
	Stu s1 = { "Frank",20,"13355669977" };
	//传值 需要开辟空间来存零时拷贝
	print1(s1);
	//传址 打印的话更优 不用开辟空间来存临时拷贝
	print2(&s1);
	return 0;
}
