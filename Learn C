
#include<stdio.h>









/////////////////////////////////////////////////////////////

int main(void)
{
	int arr[] = { 1,2,3,4,57,889 };
	printf("%p \n", arr);//数组名及首元素地址
	printf("%p \n", &arr[0]);
	printf("%d \n", *arr);//就是首元素的地址
	return 0;
}
例外情况（数组名不代表首元素地址）
1 sizeof(数组名)，此时数组名标准整个数组，求得整个数组的大小
2 &arr 取地址数组名，取出的是整个数组的地址


///////////////////////////////////////////////////////////////
算术左移，相当x2 的效果
int main(void)
{
	int a = 9;
	int b = a << 1;
	printf("%d \n", b);
	//左边丢弃，右边补0 符号位不变

	return 0;
}


移位操作符 ——算术右移位，，右移移位相当于除2 的效果
int main(void)
{
	int a = -8;
	int b = a >> 2;
	printf("%d \n", b);
	printf("%p \n", &a);
	//10000000000000000000000000001000  -8
	//10000000000000000000000000000100  -4
	return 0;
}

/////////////////////////////////////////////////////////////

int main(void)
{
	int a = 3;//00000000000000000000000000000011
	int b = 5;//00000000000000000000000000000101
	int c = a & b;//按位与 有一个0 就为0 两个都为1  才为1  00000000000000000000000000000001  1
	int d = a | b;//按位或 有一个为1则为1 两个都为0 才为0  00000000000000000000000000000111 7
	int e = a ^ b;//按位异或  相同为0 相异为1 00000000000000000000000000000110 6

	printf("%d \n", c);//1
	printf("%d \n", d);//7
	printf("%d \n", e);//6
	return 0;

//////////////////////////////////////////////////////
int main()
{
	int a = 0;
	printf("%d\n", ~a);
	//~按（二进制）位取反
	//a
	//00000000000000000000000000000000 正数的原反补码相同
	//11111111111111111111111111111111-补码 storage
	//11111111111111111111111111111110-反码
	//10000000000000000000000000000001-原码 surface  -1
	return 0;
}


//////////////////////////////////////////////////


int main()
{
	int i = 0;
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	//i = a++ && ++b && d++;//逻辑与只要遇到一个0 直到遇到0 那么后面不管是什么，忽略 1，2，3，4
	//i = a++ || ++b || d++; //1，3，3，4 逻辑或，只要遇到一个真 那么后面不管是什么 直到遇到一个真，忽略
	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);

	return 0;
}

////////////////////////////////////////////////////
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int max = (a > b ? a : b);//三目操作符
	printf("max = %d \n", max);


	return 0;
}


////////////////////////////////////////////
野指针
//临时变量出test函数后就销毁了 
int* test()
{
	int a = 10;
	return &a;
}

//*p 由于原来的地址已经销毁，故为野指针
int main()
{
	int* p =test();

	printf("%d\n", *p);
	return 0;
}
///////////////////////////////////////////
int main()
{
	//指针-指针，两个指针必须指向同一个空间
	char ch[5] = { 0 };
	int a[10] = {99,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", &a[9] - &a[0]);//指针-指针得到的是中间的元素个数；
	printf("%d\n", &a[0] - &a[9]);
	printf("%d\n", &a[9] - &ch[4]);//Wrong

	return 0;
}
/////////////////////////////
[Using point to explain strlen]
int My_strlen(char* str)
{
	char* start = str;
	char* end = str;
	while (*end != '\0')
	{
		end++;
	}
	return end - start;

}

int main(void)
{
	char arr[] = "Fuck you up";
	int len = My_strlen(arr);
	printf("%d\n", len);

	return 0;
}

///////////////////////////////////////////
struct Stu
{
	char name[20];
	short age;
	char sex[5];
}Stu; // 此处的Stu是全局变量

typedef struct Stu  //typedef 重新取个名字
{
	char name[20];
	short age;
	char sex[5];
}Stu;//重新取得名字  此处的stu是类型 而不是全局变量 =（int folat char...)


int main(void)
{
	struct Stu s = { "Frank",20,"male" };
	Stu s1;
	printf("%s\n", s);

	return 0;
}

////////////////////////////////////////////
struct S
{
	int age;
	char arr[20];
	double c;

};

struct T
{
	char ch[20];
	struct S s;
	char* p;

};

int main(void)
{
	char arr[60] = "Never gonna give you up";
	struct T t = { "hehe",{20,"aosijd",2.7},arr};//嵌套结构体

	//打印结构体内部对象 结构体名.对象
	printf("%s\n", t.ch);
	printf("%d\n", t.s.age);
	printf("%s\n", t.s.arr);

	return 0;
}

////////////////////////////////////////////////////////////
typedef struct Stu
{
	char name[29];
	short age;
	char tele[20];
}Stu;
void print1(Stu tmp)
{
	printf("name = %s\n", tmp.name);
	printf("age = %d\n", tmp.age);
	printf("tele = %s\n", tmp.tele);
}
//结构体指针
void print2(Stu* ps)
{
	printf("name = %s\n", ps->name);  //结构体指针->结构体成员
	printf("age = %d\n", ps->age);
	printf("tele = %s\n", ps->tele);
}
int main()
{
	Stu s1 = { "Frank",20,"13355669977" };
	//传值 需要开辟空间来存零时拷贝
	print1(s1);
	//传址 打印的话更优 不用开辟空间来存临时拷贝
	print2(&s1);
	return 0;
}
